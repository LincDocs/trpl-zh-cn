import{_ as o,c as t,e as r,o as c}from"./app-BTkjaAF8.js";const a={};function n(g,e){return c(),t("div",null,e[0]||(e[0]=[r('<h2 id="cargo-自定义扩展命令" tabindex="-1">Cargo 自定义扩展命令</h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch14-05-extending-cargo.md" target="_blank" rel="noopener noreferrer">ch14-05-extending-cargo.md</a><br><br><br> commit c084bdd9ee328e7e774df19882ccc139532e53d8</p></blockquote><p>Cargo 的设计使得开发者可以通过新的子命令来对 Cargo 进行扩展，而无需修改 Cargo 本身。如果 <code>$PATH</code> 中有类似 <code>cargo-something</code> 的二进制文件，就可以通过 <code>cargo something</code> 来像 Cargo 子命令一样运行它。像这样的自定义命令也可以运行 <code>cargo --list</code> 来展示出来。能够通过 <code>cargo install</code> 向 Cargo 安装扩展并可以如内建 Cargo 工具那样运行它们是 Cargo 设计上的一个非常方便的优点！</p><h2 id="总结" tabindex="-1">总结</h2><p>通过 Cargo 和 <a href="https://crates.io/" target="_blank" rel="noopener noreferrer">crates.io</a><!-- ignore --> 来分享代码是使得 Rust 生态环境可以用于许多不同的任务的重要组成部分。Rust 的标准库是小而稳定的，不过 crate 易于分享和使用，并采用一个不同于语言自身的时间线来提供改进。不要羞于在 <a href="https://crates.io/" target="_blank" rel="noopener noreferrer">crates.io</a><!-- ignore --> 上共享对你有用的代码，因为它很有可能对别人也很有用！</p>',5)]))}const i=o(a,[["render",n]]),l=JSON.parse('{"path":"/ch14-05-extending-cargo.html","title":"ch14-05-extending-cargo","lang":"zh-CN","frontmatter":{"description":"Cargo 自定义扩展命令 ch14-05-extending-cargo.md commit c084bdd9ee328e7e774df19882ccc139532e53d8 Cargo 的设计使得开发者可以通过新的子命令来对 Cargo 进行扩展，而无需修改 Cargo 本身。如果 $PATH 中有类似 cargo-something 的二进制文件...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch14-05-extending-cargo.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"Cargo 自定义扩展命令 ch14-05-extending-cargo.md commit c084bdd9ee328e7e774df19882ccc139532e53d8 Cargo 的设计使得开发者可以通过新的子命令来对 Cargo 进行扩展，而无需修改 Cargo 本身。如果 $PATH 中有类似 cargo-something 的二进制文件..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":0.89,"words":266},"filePathRelative":"ch14-05-extending-cargo.md","excerpt":"<h2>Cargo 自定义扩展命令</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch14-05-extending-cargo.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch14-05-extending-cargo.md</a><br>\\n<br><br>\\ncommit c084bdd9ee328e7e774df19882ccc139532e53d8</p>\\n</blockquote>\\n<p>Cargo 的设计使得开发者可以通过新的子命令来对 Cargo 进行扩展，而无需修改 Cargo 本身。如果 <code>$PATH</code> 中有类似 <code>cargo-something</code> 的二进制文件，就可以通过 <code>cargo something</code> 来像 Cargo 子命令一样运行它。像这样的自定义命令也可以运行 <code>cargo --list</code> 来展示出来。能够通过 <code>cargo install</code> 向 Cargo 安装扩展并可以如内建 Cargo 工具那样运行它们是 Cargo 设计上的一个非常方便的优点！</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch14-05-extending-cargo.md","value":{"title":"ch14-05-extending-cargo","path":"ch14-05-extending-cargo.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch14-05-extending-cargo.md"},{"source":"SUMMARY.md","target":"ch14-05-extending-cargo.md"}]}}}');export{i as comp,l as data};
