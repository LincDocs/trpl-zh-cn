import{_ as n,e as a,j as s,o as t}from"./app-oyO3eSzo.js";const i={};function o(c,e){return t(),a("div",null,e[0]||(e[0]=[s(`<h2 id="性能对比-循环-vs-迭代器" tabindex="-1"><a class="header-anchor" href="#性能对比-循环-vs-迭代器"><span>性能对比：循环 VS 迭代器</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch13-04-performance.md" target="_blank" rel="noopener noreferrer">ch13-04-performance.md</a><br><br><br> commit 009fffa4580ffb175f1b8470b5b12e4a63d670e4</p></blockquote><p>为了决定是否使用循环或迭代器，你需要了解哪个实现更快：使用显式 <code>for</code> 循环的 <code>search</code> 函数版本，还是使用迭代器的版本。</p><p>我们进行了一个基准测试，将阿瑟·柯南·道尔的《福尔摩斯探案集》的全部内容加载到一个 <code>String</code> 中，并在内容中查找单词 “the”。以下是使用 <code>for</code> 循环版本和使用迭代器版本的 <code>search</code> 函数的基准测试结果：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)</span></span>
<span class="line"><span>test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>结果迭代器版本还要稍微快一点！这里我们不会解释性能测试的代码，我们的目的并不是为了证明它们是完全等同的，而是得出一个怎样比较这两种实现方式性能的基本思路。</p><p>对于一个更全面的性能测试，你应该使用不同大小的文本作为 <code>contents</code>，不同的单词以及长度各异的单词作为 <code>query</code>，以及各种其他变化进行检查。关键在于：迭代器，作为一个高级的抽象，被编译成了与手写的底层代码大体一致性能的代码。迭代器是 Rust 的 <strong>零成本抽象</strong>（<em>zero-cost abstractions</em>）之一，它意味着抽象并不会引入额外的运行时开销，它与本贾尼·斯特劳斯特卢普（C++ 的设计和实现者）在 “Foundations of C++”（2012）中所定义的 <strong>零开销</strong>（<em>zero-overhead</em>）如出一辙：</p><blockquote><p>In general, C++ implementations obey the zero-overhead principle: What you don&#39;t use, you don&#39;t pay for. And further: What you do use, you couldn&#39;t hand code any better.</p><ul><li>Bjarne Stroustrup &quot;Foundations of C++&quot;</li></ul><p>从整体来说，C++ 的实现遵循了零开销原则：你不需要的，无需为它买单。更有甚者的是：你需要的时候，也无法通过手写代码做得更好。</p><ul><li>本贾尼·斯特劳斯特卢普 &quot;Foundations of C++&quot;</li></ul></blockquote><p>作为另一个例子，以下代码取自一个音频解码器。解码算法使用线性预测数学运算（linear prediction mathematical operation）来根据之前样本的线性函数预测将来的值。这些代码使用迭代器链对作用域中的三个变量进行某种数学计算：一个叫 <code>buffer</code> 的数据 slice、一个有 12 个元素的数组 <code>coefficients</code>、和一个代表位数据位移量的 <code>qlp_shift</code>。我们在这个例子中声明了这些变量，但没有为它们赋值；虽然这些代码在其上下文之外没有太多意义，不过仍是一个简明的现实例子，来展示 Rust 如何将高级概念转换为底层代码。</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let buffer: &amp;mut [i32];</span></span>
<span class="line"><span>let coefficients: [i64; 12];</span></span>
<span class="line"><span>let qlp_shift: i16;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for i in 12..buffer.len() {</span></span>
<span class="line"><span>    let prediction = coefficients.iter()</span></span>
<span class="line"><span>                                 .zip(&amp;buffer[i - 12..i])</span></span>
<span class="line"><span>                                 .map(|(&amp;c, &amp;s)| c * s as i64)</span></span>
<span class="line"><span>                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;</span></span>
<span class="line"><span>    let delta = buffer[i];</span></span>
<span class="line"><span>    buffer[i] = prediction as i32 + delta;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了计算 <code>prediction</code> 的值，这段代码遍历了 <code>coefficients</code> 中的 12 个值，使用 <code>zip</code> 方法将系数与 <code>buffer</code> 的前 12 个值组合在一起。接着将每一对值相乘，再将所有结果相加，然后将总和右移 <code>qlp_shift</code> 位。</p><p>像音频解码器这样的程序通常最看重计算的性能。这里，我们创建了一个迭代器，使用了两个适配器，接着消费了其值。那么这段 Rust 代码将会被编译为什么样的汇编代码呢？好吧，在编写本书的这个时候，它被编译成与手写的相同的汇编代码。遍历 <code>coefficients</code> 的值完全用不到循环：Rust 知道这里会迭代 12 次，所以它“展开”（unroll）了循环。展开是一种将循环迭代转换为重复代码，并移除循环控制代码开销的代码优化技术。</p><p>所有的系数都被储存在了寄存器中，这意味着访问它们非常快。这里也没有运行时数组访问边界检查。所有这些 Rust 能够提供的优化使得结果代码极为高效。现在你知道了这些，请放心大胆的使用迭代器和闭包吧！它们使得代码看起来更高级，但并不为此引入运行时性能损失。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>闭包和迭代器是 Rust 受函数式编程语言观念所启发的功能。它们对 Rust 以高性能来明确的表达高级概念的能力有很大贡献。闭包和迭代器的实现达到了不影响运行时性能的程度。这正是 Rust 致力于提供零成本抽象的目标的一部分。</p><p>现在我们改进了 I/O 项目的（代码）表现力，那么让我们来看看 <code>cargo</code> 的更多功能，这些功能将帮助我们将项目分享给全世界。</p>`,16)]))}const l=n(i,[["render",o],["__file","ch13-04-performance.html.vue"]]),p=JSON.parse('{"path":"/ch13-04-performance.html","title":"ch13-04-performance","lang":"zh-CN","frontmatter":{"description":"性能对比：循环 VS 迭代器 ch13-04-performance.md commit 009fffa4580ffb175f1b8470b5b12e4a63d670e4 为了决定是否使用循环或迭代器，你需要了解哪个实现更快：使用显式 for 循环的 search 函数版本，还是使用迭代器的版本。 我们进行了一个基准测试，将阿瑟·柯南·道尔的《福尔摩斯...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch13-04-performance.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"性能对比：循环 VS 迭代器 ch13-04-performance.md commit 009fffa4580ffb175f1b8470b5b12e4a63d670e4 为了决定是否使用循环或迭代器，你需要了解哪个实现更快：使用显式 for 循环的 search 函数版本，还是使用迭代器的版本。 我们进行了一个基准测试，将阿瑟·柯南·道尔的《福尔摩斯..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":4.11,"words":1233},"filePathRelative":"ch13-04-performance.md","excerpt":"<h2>性能对比：循环 VS 迭代器</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch13-04-performance.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch13-04-performance.md</a><br>\\n<br><br>\\ncommit 009fffa4580ffb175f1b8470b5b12e4a63d670e4</p>\\n</blockquote>\\n<p>为了决定是否使用循环或迭代器，你需要了解哪个实现更快：使用显式 <code>for</code> 循环的 <code>search</code> 函数版本，还是使用迭代器的版本。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch13-04-performance.md","value":{"title":"ch13-04-performance","path":"ch13-04-performance.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch13-04-performance.md"},{"source":"SUMMARY.md","target":"ch13-04-performance.md"}]}}}');export{l as comp,p as data};
