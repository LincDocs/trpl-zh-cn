import{_ as s,e as i,j as a,o as t}from"./app-oyO3eSzo.js";const n={};function d(c,e){return t(),i("div",null,e[0]||(e[0]=[a(`<h2 id="使用字符串储存-utf-8-编码的文本" tabindex="-1"><a class="header-anchor" href="#使用字符串储存-utf-8-编码的文本"><span>使用字符串储存 UTF-8 编码的文本</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md" target="_blank" rel="noopener noreferrer">ch08-02-strings.md</a><br><br><br> commit 668c64760b5c7ea654facb4ba5fe9faddfda27cc</p></blockquote><p>第四章已经讲过一些字符串的内容，不过现在让我们更深入地了解它。字符串是新晋 Rustacean 们通常会被困住的领域，这是由于三方面理由的结合：Rust 倾向于确保暴露出可能的错误，字符串是比很多程序员所想象的要更为复杂的数据结构，以及 UTF-8。所有这些要素结合起来对于来自其他语言背景的程序员就可能显得很困难了。</p><p>在集合章节中讨论字符串的原因是，字符串就是作为字节的集合外加一些方法实现的，当这些字节被解释为文本时，这些方法提供了实用的功能。在这一部分，我们会讲到 <code>String</code> 中那些任何集合类型都有的操作，比如创建、更新和读取。也会讨论 <code>String</code> 与其他集合不一样的地方，例如索引 <code>String</code> 是很复杂的，由于人和计算机理解 <code>String</code> 数据方式的不同。</p><h3 id="什么是字符串" tabindex="-1"><a class="header-anchor" href="#什么是字符串"><span>什么是字符串？</span></a></h3><p>在开始深入这些方面之前，我们需要讨论一下术语 <strong>字符串</strong> 的具体意义。Rust 的核心语言中只有一种字符串类型：字符串 slice <code>str</code>，它通常以被借用的形式出现，<code>&amp;str</code>。第四章讲到了 <strong>字符串 slices</strong>：它们是一些对储存在别处的 UTF-8 编码字符串数据的引用。举例来说，由于字符串字面值被储存在程序的二进制输出中，因此字符串字面值也是字符串 slices。</p><p>字符串（<code>String</code>）类型由 Rust 标准库提供，而不是编入核心语言，它是一种可增长、可变、可拥有、UTF-8 编码的字符串类型。当 Rustaceans 提及 Rust 中的 &quot;字符串 &quot;时，他们可能指的是 <code>String</code> 或 string slice <code>&amp;str</code> 类型，而不仅仅是其中一种类型。虽然本节主要讨论 <code>String</code>，但这两种类型在 Rust 的标准库中都有大量使用，而且 <code>String</code> 和 字符串 slices 都是 UTF-8 编码的。</p><h3 id="新建字符串" tabindex="-1"><a class="header-anchor" href="#新建字符串"><span>新建字符串</span></a></h3><p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，事实上 <code>String</code> 被实现为一个带有一些额外保证、限制和功能的字节 vector 的封装。其中一个同样作用于 <code>Vec&lt;T&gt;</code> 和 <code>String</code> 函数的例子是用来新建一个实例的 <code>new</code> 函数，如示例 8-11 所示。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-11：新建一个空的 <code>String</code></span></p><p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，它能用于任何实现了 <code>Display</code> trait 的类型，比如字符串字面值。示例 8-12 展示了两个例子。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-12：使用 <code>to_string</code> 方法从字符串字面值创建 <code>String</code></span></p><p>这些代码会创建包含 <code>initial contents</code> 的字符串。</p><p>也可以使用 <code>String::from</code> 函数来从字符串字面值创建 <code>String</code>。示例 8-13 中的代码等同于使用 <code>to_string</code>。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-13：使用 <code>String::from</code> 函数从字符串字面值创建 <code>String</code></span></p><p>因为字符串应用广泛，这里有很多不同的用于字符串的通用 API 可供选择。其中一些可能看起来多余，不过都有其用武之地！在这个例子中，<code>String::from</code> 和 <code>.to_string</code> 最终做了完全相同的工作，所以如何选择就是代码风格与可读性的问题了。</p><p>记住字符串是 UTF-8 编码的，所以可以包含任何可以正确编码的数据，如示例 8-14 所示。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-14：在字符串中储存不同语言的问候语</span></p><p>所有这些都是有效的 <code>String</code> 值。</p><h3 id="更新字符串" tabindex="-1"><a class="header-anchor" href="#更新字符串"><span>更新字符串</span></a></h3><p><code>String</code> 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p><h4 id="使用-push-str-和-push-附加字符串" tabindex="-1"><a class="header-anchor" href="#使用-push-str-和-push-附加字符串"><span>使用 <code>push_str</code> 和 <code>push</code> 附加字符串</span></a></h4><p>可以通过 <code>push_str</code> 方法来附加字符串 slice，从而使 <code>String</code> 变长，如示例 8-15 所示。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 附加字符串 slice</span></p><p>执行这两行代码之后，<code>s</code> 将会包含 <code>foobar</code>。<code>push_str</code> 方法采用字符串 slice，因为我们并不需要获取参数的所有权。例如，示例 8-16 中我们希望在将 <code>s2</code> 的内容附加到 <code>s1</code> 之后还能使用它。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-16：将字符串 slice 的内容附加到 <code>String</code> 后使用它</span></p><p>如果 <code>push_str</code> 方法获取了 <code>s2</code> 的所有权，就不能在最后一行打印出其值了。好在代码如我们期望那样工作！</p><p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中。示例 8-17 展示了使用 <code>push</code> 方法将字母 &quot;l&quot; 加入 <code>String</code> 的代码。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-17：使用 <code>push</code> 将一个字符加入 <code>String</code> 值中</span></p><p>执行这些代码之后，<code>s</code> 将会包含 “lol”。</p><h4 id="使用-运算符或-format-宏拼接字符串" tabindex="-1"><a class="header-anchor" href="#使用-运算符或-format-宏拼接字符串"><span>使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</span></a></h4><p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符，如示例 8-18 所示。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-18：使用 <code>+</code> 运算符将两个 <code>String</code> 值合并到一个新的 <code>String</code> 值中</span></p><p>执行完这些代码之后，字符串 <code>s3</code> 将会包含 <code>Hello, world!</code>。<code>s1</code> 在相加后不再有效的原因，和使用 <code>s2</code> 的引用的原因，与使用 <code>+</code> 运算符时调用的函数签名有关。<code>+</code> 运算符使用了 <code>add</code> 函数，这个函数签名看起来像这样：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn add(self, s: &amp;str) -&gt; String {</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在标准库中你会发现，<code>add</code> 的定义使用了泛型和关联类型。在这里我们替换为了具体类型，这也正是当使用 <code>String</code> 值调用这个方法会发生的。第十章会讨论泛型。这个签名提供了理解 <code>+</code> 运算那微妙部分的线索。</p><p>首先，<code>s2</code> 使用了 <code>&amp;</code>，意味着我们使用第二个字符串的 <strong>引用</strong> 与第一个字符串相加。这是因为 <code>add</code> 函数的 <code>s</code> 参数：只能将 <code>&amp;str</code> 和 <code>String</code> 相加，不能将两个 <code>String</code> 值相加。不过等一下 —— <code>&amp;s2</code> 的类型是 <code>&amp;String</code>, 而不是 <code>add</code> 第二个参数所指定的 <code>&amp;str</code>。那么为什么示例 8-18 还能编译呢？</p><p>之所以能够在 <code>add</code> 调用中使用 <code>&amp;s2</code> 是因为 <code>&amp;String</code> 可以被 <strong>强转</strong>（<em>coerced</em>）成 <code>&amp;str</code>。当<code>add</code>函数被调用时，Rust 使用了一个被称为 <strong>Deref 强制转换</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 <code>&amp;s2</code> 变成了 <code>&amp;s2[..]</code>。第十五章会更深入的讨论 Deref 强制转换。因为 <code>add</code> 没有获取参数的所有权，所以 <code>s2</code> 在这个操作后仍然是有效的 <code>String</code>。</p><p>其次，可以发现签名中 <code>add</code> 获取了 <code>self</code> 的所有权，因为 <code>self</code> <strong>没有</strong> 使用 <code>&amp;</code>。这意味着示例 8-18 中的 <code>s1</code> 的所有权将被移动到 <code>add</code> 调用中，之后就不再有效。所以虽然 <code>let s3 = s1 + &amp;s2;</code> 看起来就像它会复制两个字符串并创建一个新的字符串，而实际上这个语句会获取 <code>s1</code> 的所有权，附加上从 <code>s2</code> 中拷贝的内容，并返回结果的所有权。换句话说，它看起来好像生成了很多拷贝，不过实际上并没有：这个实现比拷贝要更高效。</p><p>如果想要级联多个字符串，<code>+</code> 的行为就显得笨重了：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这时 <code>s</code> 的内容会是 “tic-tac-toe”。在有这么多 <code>+</code> 和 <code>&quot;</code> 字符的情况下，很难理解具体发生了什么。对于更为复杂的字符串链接，可以使用 <code>format!</code> 宏：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这些代码也会将 <code>s</code> 设置为 “tic-tac-toe”。<code>format!</code> 与 <code>println!</code> 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 <code>String</code>。这个版本就好理解的多，宏 <code>format!</code> 生成的代码使用引用所以不会获取任何参数的所有权。</p><h3 id="索引字符串" tabindex="-1"><a class="header-anchor" href="#索引字符串"><span>索引字符串</span></a></h3><p>在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。然而在 Rust 中，如果你尝试使用索引语法访问 <code>String</code> 的一部分，会出现一个错误。考虑一下如示例 8-19 中所示的无效代码。</p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 8-19：尝试对字符串使用索引语法</span></p><p>这段代码会导致如下错误：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>错误和提示说明了全部问题：Rust 的字符串不支持索引。那么接下来的问题是，为什么不支持呢？为了回答这个问题，我们必须先聊一聊 Rust 是如何在内存中储存字符串的。</p><h4 id="内部表现" tabindex="-1"><a class="header-anchor" href="#内部表现"><span>内部表现</span></a></h4><p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。让我们看看示例 8-14 中一些正确编码的字符串的例子。首先是这一个：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在这里，<code>len</code> 的值是 4，这意味着储存字符串 “Hola” 的 <code>Vec</code> 的长度是四个字节：这里每一个字母的 UTF-8 编码都占用一个字节。那下面这个例子又如何呢？（注意这个字符串中的首字母是西里尔字母的 Ze 而不是数字 3。）</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте” 所需要的字节数，这是因为每个 Unicode 标量值需要两个字节存储。因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值。作为演示，考虑如下无效的 Rust 代码：</p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let hello = &quot;Здравствуйте&quot;;</span></span>
<span class="line"><span>let answer = &amp;hello[0];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们已经知道 <code>answer</code> 不是第一个字符 <code>3</code>。当使用 UTF-8 编码时，（西里尔字母的 Ze）<code>З</code> 的第一个字节是 <code>208</code>，第二个是 <code>151</code>，所以 <code>answer</code> 实际上应该是 <code>208</code>，不过 <code>208</code> 自身并不是一个有效的字母。返回 <code>208</code> 可不是一个请求字符串第一个字母的人所希望看到的，不过它是 Rust 在字节索引 0 位置所能提供的唯一数据。用户通常不会想要一个字节值被返回。即使这个字符串只有拉丁字母，如果 <code>&amp;&quot;hello&quot;[0]</code> 是返回字节值的有效代码，它也会返回 <code>104</code> 而不是 <code>h</code>。</p><p>为了避免返回意外的值并造成不能立刻发现的 bug，Rust 根本不会编译这些代码，并在开发过程中及早杜绝了误会的发生。</p><h4 id="字节、标量值和字形簇-天呐" tabindex="-1"><a class="header-anchor" href="#字节、标量值和字形簇-天呐"><span>字节、标量值和字形簇！天呐！</span></a></h4><p>这引起了关于 UTF-8 的另外一个问题：从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 <strong>字母</strong> 的概念）。</p><p>比如这个用梵文书写的印度语单词 “नमस्ते”，最终它储存在 vector 中的 <code>u8</code> 值看起来像这样：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,</span></span>
<span class="line"><span>224, 165, 135]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有 18 个字节，也就是计算机最终会储存的数据。如果从 Unicode 标量值的角度理解它们，也就像 Rust 的 <code>char</code> 类型那样，这些字节看起来像这样：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[&#39;न&#39;, &#39;म&#39;, &#39;स&#39;, &#39;्&#39;, &#39;त&#39;, &#39;े&#39;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里有六个 <code>char</code>，不过第四个和第六个都不是字母，它们是发音符号本身并没有任何意义。最后，如果以字形簇的角度理解，就会得到人们所说的构成这个单词的四个字母：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Rust 提供了多种不同的方式来解释计算机储存的原始字符串数据，这样程序就可以选择它需要的表现方式，而无所谓是何种人类语言。</p><p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是，索引操作预期总是需要常数时间（O(1)）。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。</p><h3 id="字符串-slice" tabindex="-1"><a class="header-anchor" href="#字符串-slice"><span>字符串 slice</span></a></h3><p>索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。因此，如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，相比使用 <code>[]</code> 和单个值的索引，可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> hello</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Здравствуйте&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">hello</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p><p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：Rust 在运行时会 panic，就跟访问 vector 中的无效索引时一样：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>你应该小心谨慎地使用这个操作，因为这么做可能会使你的程序崩溃。</p><h3 id="遍历字符串的方法" tabindex="-1"><a class="header-anchor" href="#遍历字符串的方法"><span>遍历字符串的方法</span></a></h3><p>操作字符串每一部分的最好的方法是明确表示需要字符还是字节。对于单独的 Unicode 标量值使用 <code>chars</code> 方法。对 “Зд” 调用 <code>chars</code> 方法会将其分开并返回两个 <code>char</code> 类型的值，接着就可以遍历其结果来访问每一个元素了：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> c</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Зд&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chars</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{c}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些代码会打印出如下内容：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>З</span></span>
<span class="line"><span>д</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>另外 <code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Зд&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bytes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{b}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些代码会打印出组成 <code>String</code> 的 4 个字节：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>208</span></span>
<span class="line"><span>151</span></span>
<span class="line"><span>208</span></span>
<span class="line"><span>180</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过请记住有效的 Unicode 标量值可能会由不止一个字节组成。</p><p>从字符串中获取如同天城文这样的字形簇是很复杂的，所以标准库并没有提供这个功能。<a href="https://crates.io/" target="_blank" rel="noopener noreferrer">crates.io</a><!-- ignore --> 上有些提供这样功能的 crate。</p><h3 id="字符串并不简单" tabindex="-1"><a class="header-anchor" href="#字符串并不简单"><span>字符串并不简单</span></a></h3><p>总而言之，字符串还是很复杂的。不同的语言选择了不同的向程序员展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着程序员们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发周期后期免于处理涉及非 ASCII 字符的错误。</p><p>好消息是标准库提供了很多围绕 <code>String</code> 和 <code>&amp;str</code> 构建的功能，来帮助我们正确处理这些复杂场景。请务必查看这些使用方法的文档，例如 <code>contains</code> 来搜索一个字符串，和 <code>replace</code> 将字符串的一部分替换为另一个字符串。</p><p>称作 <code>String</code> 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。当 Rustacean 们谈到 Rust 的 “字符串”时，它们通常指的是 <code>String</code> 或字符串 slice <code>&amp;str</code> 类型，而不特指其中某一个。虽然本部分内容大多是关于 <code>String</code> 的，不过这两个类型在 Rust 标准库中都被广泛使用，<code>String</code> 和字符串 slices 都是 UTF-8 编码的。</p><p>现在让我们转向一些不太复杂的集合：哈希 map！</p>`,101)]))}const o=s(n,[["render",d],["__file","ch08-02-strings.html.vue"]]),r=JSON.parse('{"path":"/ch08-02-strings.html","title":"ch08-02-strings","lang":"zh-CN","frontmatter":{"description":"使用字符串储存 UTF-8 编码的文本 ch08-02-strings.md commit 668c64760b5c7ea654facb4ba5fe9faddfda27cc 第四章已经讲过一些字符串的内容，不过现在让我们更深入地了解它。字符串是新晋 Rustacean 们通常会被困住的领域，这是由于三方面理由的结合：Rust 倾向于确保暴露出可能的错误...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch08-02-strings.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"使用字符串储存 UTF-8 编码的文本 ch08-02-strings.md commit 668c64760b5c7ea654facb4ba5fe9faddfda27cc 第四章已经讲过一些字符串的内容，不过现在让我们更深入地了解它。字符串是新晋 Rustacean 们通常会被困住的领域，这是由于三方面理由的结合：Rust 倾向于确保暴露出可能的错误..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":13.86,"words":4157},"filePathRelative":"ch08-02-strings.md","excerpt":"<h2>使用字符串储存 UTF-8 编码的文本</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch08-02-strings.md</a><br>\\n<br><br>\\ncommit 668c64760b5c7ea654facb4ba5fe9faddfda27cc</p>\\n</blockquote>\\n<p>第四章已经讲过一些字符串的内容，不过现在让我们更深入地了解它。字符串是新晋 Rustacean 们通常会被困住的领域，这是由于三方面理由的结合：Rust 倾向于确保暴露出可能的错误，字符串是比很多程序员所想象的要更为复杂的数据结构，以及 UTF-8。所有这些要素结合起来对于来自其他语言背景的程序员就可能显得很困难了。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch08-02-strings.md","value":{"title":"ch08-02-strings","path":"ch08-02-strings.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch08-02-strings.md"},{"source":"SUMMARY.md","target":"ch08-02-strings.md"}]}}}');export{o as comp,r as data};
