import{_ as r,e as a,f as i,j as t,i as s,g as n,h as o,r as l,o as c}from"./app-oyO3eSzo.js";const p={};function u(h,e){const d=l("RouteLink");return c(),a("div",null,[e[47]||(e[47]=i("h2",{id:"高级类型",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#高级类型"},[i("span",null,"高级类型")])],-1)),e[48]||(e[48]=i("blockquote",null,[i("p",null,[i("a",{href:"https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-types.md",target:"_blank",rel:"noopener noreferrer"},"ch20-04-advanced-types.md"),i("br"),i("br"),i("br"),s(" commit 95e931170404cb98d476b19017cbbdbc00d0834d")])],-1)),e[49]||(e[49]=i("p",null,[s("Rust 的类型系统有一些我们曾经提到但没有讨论过的功能。首先我们从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始。接着会转向类型别名（type aliases），一个类似于 newtype 但有着稍微不同的语义的功能。我们还会讨论 "),i("code",null,"!"),s(" 类型和动态大小类型。")],-1)),i("blockquote",null,[i("p",null,[e[1]||(e[1]=s("这一部分假设你已经阅读了之前的 ")),n(d,{to:"/ch20-03-advanced-traits.html#newtype-%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BB%A5%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8-trait"},{default:o(()=>e[0]||(e[0]=[s("“newtype 模式用于在外部类型上实现外部 trait”")])),_:1}),e[2]||(e[2]=s(" 部分。"))])]),e[50]||(e[50]=t('<h3 id="为了类型安全和抽象而使用-newtype-模式" tabindex="-1"><a class="header-anchor" href="#为了类型安全和抽象而使用-newtype-模式"><span>为了类型安全和抽象而使用 newtype 模式</span></a></h3><p>newtype 模式也可以用于一些其他我们还未讨论的功能，包括静态的确保某值不被混淆，和用来表示一个值的单位。实际上示例 19-15 中已经有一个这样的例子：<code>Millimeters</code> 和 <code>Meters</code> 结构体都在 newtype 中封装了 <code>u32</code> 值。如果编写了一个有 <code>Millimeters</code> 类型参数的函数，不小心使用 <code>Meters</code> 或普通的 <code>u32</code> 值来调用该函数的程序是不能编译的。</p><p>newtype 模式也可以用于抽象掉一些类型的实现细节：例如，封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API。</p>',3)),i("p",null,[e[4]||(e[4]=s("newtype 也可以隐藏其内部的泛型类型。例如，可以提供一个封装了 ")),e[5]||(e[5]=i("code",null,"HashMap<i32, String>",-1)),e[6]||(e[6]=s(" 的 ")),e[7]||(e[7]=i("code",null,"People",-1)),e[8]||(e[8]=s(" 类型，用来储存人名以及相应的 ID。使用 ")),e[9]||(e[9]=i("code",null,"People",-1)),e[10]||(e[10]=s(" 的代码只需与提供的公有 API 交互即可，比如向 ")),e[11]||(e[11]=i("code",null,"People",-1)),e[12]||(e[12]=s(" 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 ")),e[13]||(e[13]=i("code",null,"i32",-1)),e[14]||(e[14]=s(" ID 赋予了这个名字了。newtype 模式是一种实现第十八章 ")),n(d,{to:"/ch18-01-what-is-oo.html#%E5%B0%81%E8%A3%85%E9%9A%90%E8%97%8F%E4%BA%86%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"},{default:o(()=>e[3]||(e[3]=[s("“封装隐藏了实现细节”")])),_:1}),e[15]||(e[15]=s(" 部分所讨论的隐藏实现细节的封装的轻量级方法。"))]),e[51]||(e[51]=t('<h3 id="类型别名用来创建类型同义词" tabindex="-1"><a class="header-anchor" href="#类型别名用来创建类型同义词"><span>类型别名用来创建类型同义词</span></a></h3><p>Rust 提供了声明 <strong>类型别名</strong>（<em>type alias</em>）的能力，使用 <code>type</code> 关键字来给予现有类型另一个名字。例如，可以像这样创建 <code>i32</code> 的别名 <code>Kilometers</code>：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-04-kilometers-alias/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这意味着 <code>Kilometers</code> 是 <code>i32</code> 的 <strong>同义词</strong>（<em>synonym</em>）；不同于示例 19-15 中创建的 <code>Millimeters</code> 和 <code>Meters</code> 类型。<code>Kilometers</code> 不是一个新的、单独的类型。<code>Kilometers</code> 类型的值将被完全当作 <code>i32</code> 类型值来对待：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-04-kilometers-alias/src/main.rs:there}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为 <code>Kilometers</code> 是 <code>i32</code> 的别名，它们是同一类型，可以将 <code>i32</code> 与 <code>Kilometers</code> 相加，也可以将 <code>Kilometers</code> 传递给获取 <code>i32</code> 参数的函数。但通过这种手段无法获得上一部分讨论的 newtype 模式所提供的类型检查的好处。换句话说，如果在哪里混用 <code>Kilometers</code> 和 <code>i32</code> 的值，编译器也不会给出一个错误。</p><p>类型别名的主要用途是减少重复。例如，可能会有这样很长的类型：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Box&lt;dyn Fn() + Send + &#39;static&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在函数签名或类型注解中每次都书写这个类型将是枯燥且易于出错的。想象一下如示例 19-24 这样全是如此代码的项目：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-24/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 19-24: 在很多地方使用名称很长的类型</span></p><p>类型别名通过减少项目中重复代码的数量来使其更加易于控制。这里我们为这个冗长的类型引入了一个叫做 <code>Thunk</code> 的别名，这样就可以如示例 19-25 所示将所有使用这个类型的地方替换为更短的 <code>Thunk</code>：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-25/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 19-25: 引入类型别名 <code>Thunk</code> 来减少重复</span></p><p>这样读写起来就容易多了！为类型别名选择一个好名字也可以帮助你表达意图（单词 <em>thunk</em> 表示会在之后被计算的代码，所以这是一个存放闭包的合适的名字）。</p><p>类型别名也经常与 <code>Result&lt;T, E&gt;</code> 结合使用来减少重复。考虑一下标准库中的 <code>std::io</code> 模块。I/O 操作通常会返回一个 <code>Result&lt;T, E&gt;</code>，因为这些操作可能会失败。标准库中的 <code>std::io::Error</code> 结构体代表了所有可能的 I/O 错误。<code>std::io</code> 中大部分函数会返回 <code>Result&lt;T, E&gt;</code>，其中 <code>E</code> 是 <code>std::io::Error</code>，比如 <code>Write</code> trait 中的这些函数：</p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-05-write-trait/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里出现了很多的 <code>Result&lt;..., Error&gt;</code>。为此，<code>std::io</code> 有这个类型别名声明：</p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-06-result-alias/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为这位于 <code>std::io</code> 中，可用的完全限定的别名是 <code>std::io::Result&lt;T&gt;</code>；也就是说，<code>Result&lt;T, E&gt;</code> 中 <code>E</code> 放入了 <code>std::io::Error</code>。<code>Write</code> trait 中的函数最终看起来像这样：</p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-06-result-alias/src/lib.rs:there}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>类型别名在两个方面有帮助：易于编写 <strong>并</strong> 在整个 <code>std::io</code> 中提供了一致的接口。因为这是一个别名，它只是另一个 <code>Result&lt;T, E&gt;</code>，这意味着可以在其上使用 <code>Result&lt;T, E&gt;</code> 的任何方法，以及像 <code>?</code> 这样的特殊语法。</p><h3 id="从不返回的-never-type" tabindex="-1"><a class="header-anchor" href="#从不返回的-never-type"><span>从不返回的 never type</span></a></h3><p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 <em>empty type</em>，因为它没有值。我们更倾向于称之为 <em>never type</em>。这个名字描述了它的作用：在函数从不返回的时候充当返回值。例如：</p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-07-never-type/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这读 “函数 <code>bar</code> 从不返回”，而从不返回的函数被称为 <strong>发散函数</strong>（<em>diverging functions</em>）。不能创建 <code>!</code> 类型的值，所以 <code>bar</code> 也不可能返回值。</p><p>不过一个不能创建值的类型有什么用呢？如果你回想一下示例 2-5 中的代码，曾经有一些看起来像这样的代码，如示例 19-26 所重现的：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:ch19}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 19-26: <code>match</code> 语句和一个以 <code>continue</code> 结束的分支</span></p>',29)),i("p",null,[e[17]||(e[17]=s("当时我们忽略了代码中的一些细节。在第六章 ")),n(d,{to:"/ch06-02-match.html#match-%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84"},{default:o(()=>e[16]||(e[16]=[s("“"),i("code",null,"match",-1),s(" 控制流运算符”")])),_:1}),e[18]||(e[18]=s(" 部分，我们学习了 ")),e[19]||(e[19]=i("code",null,"match",-1)),e[20]||(e[20]=s(" 的分支必须返回相同的类型。如下代码不能工作："))]),e[52]||(e[52]=t('<div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-08-match-arms-different-types/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的 <code>guess</code> 必须既是整型 <strong>也是</strong> 字符串，而 Rust 要求 <code>guess</code> 只能是一个类型。那么 <code>continue</code> 返回了什么呢？为什么示例 19-26 中会允许一个分支返回 <code>u32</code> 而另一个分支却以 <code>continue</code> 结束呢？</p><p>正如你可能猜到的，<code>continue</code> 的值是 <code>!</code>。也就是说，当 Rust 要计算 <code>guess</code> 的类型时，它查看这两个分支。前者是 <code>u32</code> 值，而后者是 <code>!</code> 值。因为 <code>!</code> 并没有一个值，Rust 决定 <code>guess</code> 的类型是 <code>u32</code>。</p><p>描述 <code>!</code> 的行为的正式方式是 never type 可以强转为任何其他类型。允许 <code>match</code> 的分支以 <code>continue</code> 结束是因为 <code>continue</code> 并不真正返回一个值；相反它把控制权交回上层循环，所以在 <code>Err</code> 的情况，事实上并未对 <code>guess</code> 赋值。</p><p>never type 的另一个用途是 <code>panic!</code>。还记得 <code>Option&lt;T&gt;</code> 上的 <code>unwrap</code> 函数吗？它产生一个值或 panic。这里是它的定义：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-09-unwrap-definition/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里与示例 19-34 中的 <code>match</code> 发生了相同的情况：Rust 知道 <code>val</code> 是 <code>T</code> 类型，<code>panic!</code> 是 <code>!</code> 类型，所以整个 <code>match</code> 表达式的结果是 <code>T</code> 类型。这能工作是因为 <code>panic!</code> 并不产生一个值；它会终止程序。对于 <code>None</code> 的情况，<code>unwrap</code> 并不返回一个值，所以这些代码是有效的。</p><p>最后一个有着 <code>!</code> 类型的表达式是 <code>loop</code>：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-10-loop-returns-never/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里，循环永远也不结束，所以此表达式的值是 <code>!</code>。但是如果引入 <code>break</code> 这就不为真了，因为循环在执行到 <code>break</code> 后就会终止。</p><h3 id="动态大小类型和-sized-trait" tabindex="-1"><a class="header-anchor" href="#动态大小类型和-sized-trait"><span>动态大小类型和 <code>Sized</code> trait</span></a></h3><p>Rust 需要知道有关类型的某些细节，例如为特定类型的值需要分配多少空间。这便是起初留下的一个类型系统中令人迷惑的角落：即 <strong>动态大小类型</strong>（<em>dynamically sized types</em>）。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。</p><p>让我们深入研究一个贯穿本书都在使用的动态大小类型的细节：<code>str</code>。没错，不是 <code>&amp;str</code>，而是 <code>str</code> 本身。<code>str</code> 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道其大小，也就意味着不能创建 <code>str</code> 类型的变量，也不能获取 <code>str</code> 类型的参数。考虑一下这些代码，它们不能工作：</p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。如果允许编写这样的代码，也就意味着这两个 <code>str</code> 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。</p>',15)),i("p",null,[e[22]||(e[22]=s("那么该怎么办呢？你已经知道了这种问题的答案：")),e[23]||(e[23]=i("code",null,"s1",-1)),e[24]||(e[24]=s(" 和 ")),e[25]||(e[25]=i("code",null,"s2",-1)),e[26]||(e[26]=s(" 的类型是 ")),e[27]||(e[27]=i("code",null,"&str",-1)),e[28]||(e[28]=s(" 而不是 ")),e[29]||(e[29]=i("code",null,"str",-1)),e[30]||(e[30]=s("。如果你回想第四章 ")),n(d,{to:"/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice"},{default:o(()=>e[21]||(e[21]=[s("“字符串 slice”")])),_:1}),e[31]||(e[31]=t(" 部分，slice 数据结构仅仅储存了开始位置和 slice 的长度。所以虽然 <code>&amp;T</code> 是一个储存了 <code>T</code> 所在的内存位置的单个值，<code>&amp;str</code> 则是 <strong>两个</strong> 值：<code>str</code> 的地址和其长度。这样，<code>&amp;str</code> 就有了一个在编译时可以知道的大小：它是 <code>usize</code> 长度的两倍。也就是说，我们总是知道 <code>&amp;str</code> 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：它们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。",17))]),i("p",null,[e[33]||(e[33]=s("可以将 ")),e[34]||(e[34]=i("code",null,"str",-1)),e[35]||(e[35]=s(" 与所有类型的指针结合：比如 ")),e[36]||(e[36]=i("code",null,"Box<str>",-1)),e[37]||(e[37]=s(" 或 ")),e[38]||(e[38]=i("code",null,"Rc<str>",-1)),e[39]||(e[39]=s("。事实上，之前我们已经见过了，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。在第十八章 ")),n(d,{to:"/ch18-02-trait-objects.html#%E9%A1%BE%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84-trait-%E5%AF%B9%E8%B1%A1"},{default:o(()=>e[32]||(e[32]=[s("顾及不同类型值的 trait 对象”")])),_:1}),e[40]||(e[40]=s(" 部分，我们提到了为了将 trait 用于 trait 对象，必须将它们放入指针之后，比如 ")),e[41]||(e[41]=i("code",null,"&dyn Trait",-1)),e[42]||(e[42]=s(" 或 ")),e[43]||(e[43]=i("code",null,"Box<dyn Trait>",-1)),e[44]||(e[44]=s("（")),e[45]||(e[45]=i("code",null,"Rc<dyn Trait>",-1)),e[46]||(e[46]=s(" 也可以）。"))]),e[53]||(e[53]=t('<p>为了处理 DST，Rust 提供了 <code>Sized</code> trait 来决定一个类型的大小是否在编译时可知。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，Rust 隐式的为每一个泛型函数增加了 <code>Sized</code> bound。也就是说，对于如下泛型函数定义：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>实际上被当作如下处理：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>?Sized</code> 上的 trait bound 意味着 “<code>T</code> 可能是也可能不是 <code>Sized</code>” 同时这个注解会覆盖泛型类型必须在编译时拥有固定大小的默认规则。这种意义的 <code>?Trait</code> 语法只能用于 <code>Sized</code> ，而不能用于任何其他 trait。</p><p>另外注意我们将 <code>t</code> 参数的类型从 <code>T</code> 变为了 <code>&amp;T</code>：因为其类型可能不是 <code>Sized</code> 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。</p><p>接下来，让我们讨论一下函数和闭包！</p>',9))])}const b=r(p,[["render",u],["__file","ch20-04-advanced-types.html.vue"]]),m=JSON.parse('{"path":"/ch20-04-advanced-types.html","title":"ch20-04-advanced-types","lang":"zh-CN","frontmatter":{"description":"高级类型 ch20-04-advanced-types.md commit 95e931170404cb98d476b19017cbbdbc00d0834d Rust 的类型系统有一些我们曾经提到但没有讨论过的功能。首先我们从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始。接着会转向类型别名（type aliases），一个类似于 n...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch20-04-advanced-types.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"高级类型 ch20-04-advanced-types.md commit 95e931170404cb98d476b19017cbbdbc00d0834d Rust 的类型系统有一些我们曾经提到但没有讨论过的功能。首先我们从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始。接着会转向类型别名（type aliases），一个类似于 n..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":10.44,"words":3131},"filePathRelative":"ch20-04-advanced-types.md","excerpt":"<h2>高级类型</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-types.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch20-04-advanced-types.md</a><br>\\n<br><br>\\ncommit 95e931170404cb98d476b19017cbbdbc00d0834d</p>\\n</blockquote>\\n<p>Rust 的类型系统有一些我们曾经提到但没有讨论过的功能。首先我们从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始。接着会转向类型别名（type aliases），一个类似于 newtype 但有着稍微不同的语义的功能。我们还会讨论 <code>!</code> 类型和动态大小类型。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch20-04-advanced-types.md","value":{"title":"ch20-04-advanced-types","path":"ch20-04-advanced-types.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"ch20-04-advanced-types.md"}]}}}');export{b as comp,m as data};
