import{_ as r,e as d,j as s,f as o,i,g as t,h as c,r as a,o as l}from"./app-CtoJuC-b.js";const p={};function u(g,e){const n=a("RouteLink");return l(),d("div",null,[e[19]||(e[19]=s('<h2 id="改进-i-o-项目" tabindex="-1"><a class="header-anchor" href="#改进-i-o-项目"><span>改进 I/O 项目</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md" target="_blank" rel="noopener noreferrer">ch13-03-improving-our-io-project.md</a><br><br><br> commit 2cd1b5593d26dc6a03c20f8619187ad4b2485552</p></blockquote><p>掌握了这些关于迭代器的新知识后，我们可以使用迭代器来改进第十二章中 I/O 项目的实现来使得代码更简洁明了。接下来，让我们看看迭代器如何改进 <code>Config::build</code> 函数和 <code>search</code> 函数的实现。</p><h3 id="使用迭代器去除-clone" tabindex="-1"><a class="header-anchor" href="#使用迭代器去除-clone"><span>使用迭代器去除 <code>clone</code></span></a></h3><p>在示例 12-6 中，我们增加了一些代码获取一个 <code>String</code> 类型的 slice 并创建一个 <code>Config</code> 结构体的实例，它们索引 slice 中的值并克隆这些值以便 <code>Config</code> 结构体可以拥有这些值。在示例 13-17 中重现了第十二章结尾示例 12-23 中 <code>Config::build</code> 函数的实现：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/lib.rs:ch13}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 13-17：重现示例 12-23 的 <code>Config::build</code> 函数</span></p><p>当时我们说过不必担心低效的 <code>clone</code> 调用，因为我们以后会将其移除。好吧，就是现在！</p><p>起初这里需要 <code>clone</code> 的原因是参数 <code>args</code> 中有一个 <code>String</code> 元素的 slice，而 <code>build</code> 函数并不拥有 <code>args</code>。为了能够返回 <code>Config</code> 实例的所有权，我们需要克隆 <code>Config</code> 中字段 <code>query</code> 和 <code>file_path</code> 的值，这样 <code>Config</code> 实例就能拥有这些值。</p><p>在学习了迭代器之后，我们可以将 <code>build</code> 函数改为获取一个有所有权的迭代器作为参数，而不是借用 slice。我们将使用迭代器功能代替之前检查 slice 长度和索引特定位置的代码。这样可以更清晰地表达 <code>Config::build</code> 函数的操作，因为迭代器会负责访问这些值。</p><p>一旦 <code>Config::build</code> 获取了迭代器的所有权并不再使用借用的索引操作，就可以将迭代器中的 <code>String</code> 值移动到 <code>Config</code> 中，而不是调用 <code>clone</code> 分配新的空间。</p><h4 id="直接使用返回的迭代器" tabindex="-1"><a class="header-anchor" href="#直接使用返回的迭代器"><span>直接使用返回的迭代器</span></a></h4><p>打开 I/O 项目的 <em>src/main.rs</em> 文件，它看起来应该像这样：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>首先我们修改第十二章结尾示例 12-24 中的 <code>main</code> 函数的开头为示例 13-18 中的代码。在更新 <code>Config::build</code> 之前这些代码还不能编译：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 13-18：将 <code>env::args</code> 的返回值传递给 <code>Config::build</code></span></p><p><code>env::args</code> 函数返回一个迭代器！不同于将迭代器的值收集到一个 vector 中接着传递一个 slice 给 <code>Config::build</code>，现在我们直接将 <code>env::args</code> 返回的迭代器的所有权传递给 <code>Config::build</code>。</p><p>接下来需要更新 <code>Config::build</code> 的定义。在 I/O 项目的 <em>src/lib.rs</em> 中，将 <code>Config::build</code> 的签名改为如示例 13-19 所示。这仍然不能编译因为我们还需更新函数体。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 13-19：以迭代器作为参数更新 <code>Config::build</code> 的签名</span></p><p><code>env::args</code> 函数的标准库文档显示，它返回的迭代器的类型为 <code>std::env::Args</code>，并且这个类型实现了 <code>Iterator</code> trait 并返回 <code>String</code> 值。</p>',26)),o("p",null,[e[1]||(e[1]=i("我们已经更新了 ")),e[2]||(e[2]=o("code",null,"Config::build",-1)),e[3]||(e[3]=i(" 函数的签名，因此参数 ")),e[4]||(e[4]=o("code",null,"args",-1)),e[5]||(e[5]=i(" 有一个带有 trait bounds ")),e[6]||(e[6]=o("code",null,"impl Iterator<Item = String>",-1)),e[7]||(e[7]=i(" 的泛型类型，而不是 ")),e[8]||(e[8]=o("code",null,"&[String]",-1)),e[9]||(e[9]=i("。这里用到了第十章 ")),t(n,{to:"/ch10-02-traits.html#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"},{default:c(()=>e[0]||(e[0]=[i("“trait 作为参数”")])),_:1}),e[10]||(e[10]=i(" 部分讨论过的 ")),e[11]||(e[11]=o("code",null,"impl Trait",-1)),e[12]||(e[12]=i(" 语法，这意味着 ")),e[13]||(e[13]=o("code",null,"args",-1)),e[14]||(e[14]=i(" 可以是任何实现了 ")),e[15]||(e[15]=o("code",null,"Iterator",-1)),e[16]||(e[16]=i(" trait 并返回 ")),e[17]||(e[17]=o("code",null,"String",-1)),e[18]||(e[18]=i(" 项（item）的类型。"))]),e[20]||(e[20]=s('<p>由于我们获取了 <code>args</code> 的所有权，并且将通过迭代来修改 <code>args</code>，因此我们可以在 <code>args</code> 参数的声明中添加 <code>mut</code> 关键字，使其可变。</p><h4 id="使用-iterator-trait-代替索引" tabindex="-1"><a class="header-anchor" href="#使用-iterator-trait-代替索引"><span>使用 <code>Iterator</code> trait 代替索引</span></a></h4><p>接下来，我们将修改 <code>Config::build</code> 的函数体。因为 <code>args</code> 实现了 <code>Iterator</code> trait，因此我们知道可以对其调用 <code>next</code> 方法！示例 13-20 更新了示例 12-23 中的代码，以使用 <code>next</code> 方法：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 13-20：修改 <code>Config::build</code> 的函数体来使用迭代器方法</span></p><p>请记住 <code>env::args</code> 返回值的第一个值是程序的名称。我们希望忽略它并获取下一个值，所以首先调用 <code>next</code> 且不对其返回值做任何操作。然后，我们再次调用 <code>next</code> 来获取要放入 <code>Config</code> 结构体的 <code>query</code> 字段的值。如果 <code>next</code> 返回 <code>Some</code>，使用 <code>match</code> 来提取其值。如果它返回 <code>None</code>，则意味着没有提供足够的参数并通过 <code>Err</code> 值提早返回。我们对 <code>file_path</code> 的值也进行同样的操作。</p><h3 id="使用迭代器适配器来使代码更简明" tabindex="-1"><a class="header-anchor" href="#使用迭代器适配器来使代码更简明"><span>使用迭代器适配器来使代码更简明</span></a></h3><p>I/O 项目中其他可以利用迭代器的地方是 <code>search</code> 函数，示例 13-21 中重现了第十二章结尾示例 12-19 中此函数的定义：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 13-21：示例 12-19 中 <code>search</code> 函数的定义</span></p><p>可以通过使用迭代器适配器方法来编写更简明的代码。这样做还可以避免使用一个可变的中间 <code>results</code> vector。函数式编程风格倾向于最小化可变状态的数量来使代码更简洁。去除可变状态可能会使未来的并行搜索优化变得更容易，因为我们不必管理对 <code>results</code> vector 的并发访问。示例 13-22 展示了这一变化：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 13-22：在 <code>search</code> 函数实现中使用迭代器适配器</span></p><p>回忆一下，<code>search</code> 函数的目的是返回所有 <code>contents</code> 中包含 <code>query</code> 的行。类似于示例 13-16 中的 <code>filter</code> 例子，这段代码使用 <code>filter</code> 适配器来保留 <code>line.contains(query)</code> 返回 <code>true</code> 的行。接着使用 <code>collect</code> 将匹配行收集到另一个 vector 中。这样就容易多了！尝试对 <code>search_case_insensitive</code> 函数做出同样的使用迭代器方法的修改吧。</p><h3 id="选择循环或迭代器" tabindex="-1"><a class="header-anchor" href="#选择循环或迭代器"><span>选择循环或迭代器</span></a></h3><p>接下来的逻辑问题就是在代码中应该选择哪种风格，以及原因：是使用示例 13-21 中的原始实现还是使用示例 13-22 中使用迭代器的版本？大部分 Rust 程序员倾向于使用迭代器风格。开始这有点难以掌握，不过一旦你对不同迭代器的工作方式有了感觉之后，迭代器反而更容易理解。相比摆弄不同的循环并创建新 vector，（迭代器）代码则更关注循环的高层次目的。这抽象掉那些老生常谈的代码，这样就更容易看清代码所特有的概念，比如迭代器中每个元素必须满足的过滤条件。</p><p>不过这两种实现真的完全等价吗？直觉上的假设是更底层的循环会更快一些。让我们聊聊性能吧。</p>',20))])}const m=r(p,[["render",u],["__file","ch13-03-improving-our-io-project.html.vue"]]),b=JSON.parse('{"path":"/ch13-03-improving-our-io-project.html","title":"ch13-03-improving-our-io-project","lang":"zh-CN","frontmatter":{"description":"改进 I/O 项目 ch13-03-improving-our-io-project.md commit 2cd1b5593d26dc6a03c20f8619187ad4b2485552 掌握了这些关于迭代器的新知识后，我们可以使用迭代器来改进第十二章中 I/O 项目的实现来使得代码更简洁明了。接下来，让我们看看迭代器如何改进 Config::buil...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch13-03-improving-our-io-project.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"改进 I/O 项目 ch13-03-improving-our-io-project.md commit 2cd1b5593d26dc6a03c20f8619187ad4b2485552 掌握了这些关于迭代器的新知识后，我们可以使用迭代器来改进第十二章中 I/O 项目的实现来使得代码更简洁明了。接下来，让我们看看迭代器如何改进 Config::buil..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":6.01,"words":1802},"filePathRelative":"ch13-03-improving-our-io-project.md","excerpt":"<h2>改进 I/O 项目</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch13-03-improving-our-io-project.md</a><br>\\n<br><br>\\ncommit 2cd1b5593d26dc6a03c20f8619187ad4b2485552</p>\\n</blockquote>\\n<p>掌握了这些关于迭代器的新知识后，我们可以使用迭代器来改进第十二章中 I/O 项目的实现来使得代码更简洁明了。接下来，让我们看看迭代器如何改进 <code>Config::build</code> 函数和 <code>search</code> 函数的实现。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch13-03-improving-our-io-project.md","value":{"title":"ch13-03-improving-our-io-project","path":"ch13-03-improving-our-io-project.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch13-03-improving-our-io-project.md"},{"source":"SUMMARY.md","target":"ch13-03-improving-our-io-project.md"}]}}}');export{m as comp,b as data};
