import{_ as r,e as n,j as d,f as o,i as t,g as i,h as a,r as c,o as l}from"./app-ka1GL8-S.js";const p={};function u(h,e){const s=c("RouteLink");return l(),n("div",null,[e[19]||(e[19]=d('<h2 id="引用模块项目的路径" tabindex="-1">引用模块项目的路径</h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md" target="_blank" rel="noopener noreferrer">ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md</a><br><br><br> commit 2b4565662d1a7973d870744a923f58f8f7dcce91</p></blockquote><p>来看一下 Rust 如何在模块树中找到一个项的位置，我们使用路径的方式，就像在文件系统使用路径一样。为了调用一个函数，我们需要知道它的路径。</p><p>路径有两种形式：</p><ul><li><strong>绝对路径</strong>（<em>absolute path</em>）是以 crate 根（root）开头的全路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于当前 crate 的代码，则以字面值 <code>crate</code> 开头。</li><li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或定义在当前模块中的标识符开头。</li></ul><p>绝对路径和相对路径都后跟一个或多个由双冒号（<code>::</code>）分割的标识符。</p><p>回到示例 7-1，假设我们希望调用 <code>add_to_waitlist</code> 函数。还是同样的问题，<code>add_to_waitlist</code> 函数的路径是什么？在示例 7-3 中删除了一些模块和函数。</p>',7)),o("p",null,[e[1]||(e[1]=t("我们在 crate 根定义了一个新函数 ")),e[2]||(e[2]=o("code",null,"eat_at_restaurant",-1)),e[3]||(e[3]=t("，并在其中展示调用 ")),e[4]||(e[4]=o("code",null,"add_to_waitlist",-1)),e[5]||(e[5]=t(" 函数的两种方法。")),e[6]||(e[6]=o("code",null,"eat_at_restaurant",-1)),e[7]||(e[7]=t(" 函数是我们 crate 库的一个公共 API，所以我们使用 ")),e[8]||(e[8]=o("code",null,"pub",-1)),e[9]||(e[9]=t(" 关键字来标记它。在 ")),i(s,{to:"/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-pub-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9A%B4%E9%9C%B2%E8%B7%AF%E5%BE%84"},{default:a(()=>e[0]||(e[0]=[t("“使用 "),o("code",null,"pub",-1),t(" 关键字暴露路径”")])),_:1}),e[10]||(e[10]=t(" 一节，我们将详细介绍 ")),e[11]||(e[11]=o("code",null,"pub",-1)),e[12]||(e[12]=t("。注意，这个例子无法编译通过，我们稍后会解释原因。"))]),e[20]||(e[20]=d('<p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-3: 使用绝对路径和相对路径来调用 <code>add_to_waitlist</code> 函数</span></p><p>第一种方式，我们在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数，使用的是绝对路径。<code>add_to_waitlist</code> 函数与 <code>eat_at_restaurant</code> 被定义在同一 crate 中，这意味着我们可以使用 <code>crate</code> 关键字为起始的绝对路径。</p><p>在 <code>crate</code> 后面，我们持续地嵌入模块，直到我们找到 <code>add_to_waitlist</code>。你可以想象出一个相同结构的文件系统，我们通过指定路径 <code>/front_of_house/hosting/add_to_waitlist</code> 来执行 <code>add_to_waitlist</code> 程序。我们使用 <code>crate</code> 从 crate 根开始就类似于在 shell 中使用 <code>/</code> 从文件系统根开始。</p><p>第二种方式，我们在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code>，使用的是相对路径。这个路径以 <code>front_of_house</code> 为起始，这个模块在模块树中，与 <code>eat_at_restaurant</code> 定义在同一层级。与之等价的文件系统路径就是 <code>front_of_house/hosting/add_to_waitlist</code>。以模块名开头意味着该路径是相对路径。</p><p>选择使用相对路径还是绝对路径，要取决于你的项目，也取决于你是更倾向于将项的定义代码与使用该项的代码分开来移动，还是一起移动。举一个例子，如果我们要将 <code>front_of_house</code> 模块和 <code>eat_at_restaurant</code> 函数一起移动到一个名为 <code>customer_experience</code> 的模块中，我们需要更新 <code>add_to_waitlist</code> 的绝对路径，但是相对路径还是可用的。然而，如果我们要将 <code>eat_at_restaurant</code> 函数单独移到一个名为 <code>dining</code> 的模块中，还是可以使用原本的绝对路径来调用 <code>add_to_waitlist</code>，但是相对路径必须要更新。我们更倾向于使用绝对路径，因为把代码定义和项调用各自独立地移动是更常见的。</p><p>让我们试着编译一下示例 7-3，并查明为何不能编译！示例 7-4 展示了这个错误。</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-4: 构建示例 7-3 出现的编译器错误</span></p><p>错误信息说 <code>hosting</code> 模块是私有的。换句话说，我们拥有 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数的正确路径，但是 Rust 不让我们使用，因为它不能访问私有片段。在 Rust 中，默认所有项（函数、方法、结构体、枚举、模块和常量）对父模块都是私有的。如果希望创建一个私有函数或结构体，你可以将其放入一个模块。</p><p>父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项。这是因为子模块封装并隐藏了它们的实现详情，但是子模块可以看到它们定义的上下文。继续拿餐馆作比喻，把私有性规则想象成餐馆的后台办公室：餐馆内的事务对餐厅顾客来说是不可知的，但办公室经理可以洞悉其经营的餐厅并在其中做任何事情。</p><p>Rust 选择以这种方式来实现模块系统功能，因此默认隐藏内部实现细节。这样一来，你就知道可以更改内部代码的哪些部分而不会破坏外部代码。不过 Rust 也确实提供了通过使用 <code>pub</code> 关键字来创建公共项，使子模块的内部部分暴露给上级模块。</p><h3 id="使用-pub-关键字暴露路径" tabindex="-1">使用 <code>pub</code> 关键字暴露路径</h3><p>让我们回头看一下示例 7-4 的错误，它告诉我们 <code>hosting</code> 模块是私有的。我们想让父模块中的 <code>eat_at_restaurant</code> 函数可以访问子模块中的 <code>add_to_waitlist</code> 函数，因此我们使用 <code>pub</code> 关键字来标记 <code>hosting</code> 模块，如示例 7-5 所示。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-5: 使用 <code>pub</code> 关键字声明 <code>hosting</code> 模块使其可在 <code>eat_at_restaurant</code> 使用</span></p><p>不幸的是，示例 7-5 的代码编译仍然有错误，如示例 7-6 所示。</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-6: 构建示例 7-5 出现的编译器错误</span></p><p>发生了什么？在 <code>mod hosting</code> 前添加了 <code>pub</code> 关键字，使其变成公有的。伴随着这种变化，如果我们可以访问 <code>front_of_house</code>，那我们也可以访问 <code>hosting</code>。但是 <code>hosting</code> 的 <em>内容</em>（<em>contents</em>）仍然是私有的；这表明使模块公有并不使其内容也是公有的。模块上的 <code>pub</code> 关键字只允许其父模块引用它，而不允许访问内部代码。因为模块是一个容器，只是将模块变为公有能做的其实并不太多；同时需要更深入地选择将一个或多个项变为公有。</p><p>示例 7-6 中的错误说，<code>add_to_waitlist</code> 函数是私有的。私有性规则不但应用于模块，还应用于结构体、枚举、函数和方法。</p><p>让我们继续将 <code>pub</code> 关键字放置在 <code>add_to_waitlist</code> 函数的定义之前，使其变成公有。如示例 7-7 所示。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground,test_harness line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,test_harness" data-title="rust,noplayground,test_harness" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-7: 为 <code>mod hosting</code><br> 和 <code>fn add_to_waitlist</code> 添加 <code>pub</code> 关键字使它们可以在<br><code>eat_at_restaurant</code> 函数中被调用</span></p><p>现在代码可以编译通过了！为了了解为何增加 <code>pub</code> 关键字使得我们可以在 <code>eat_at_restaurant</code> 中调用这些路径与私有性规则有关，让我们看看绝对路径和相对路径。</p><p>在绝对路径，我们从 <code>crate</code> 也就是 crate 根开始。crate 根中定义了 <code>front_of_house</code> 模块。虽然 <code>front_of_house</code> 模块不是公有的，不过因为 <code>eat_at_restaurant</code> 函数与 <code>front_of_house</code> 定义于同一模块中（即，<code>eat_at_restaurant</code> 和 <code>front_of_house</code> 是兄弟），我们可以从 <code>eat_at_restaurant</code> 中引用 <code>front_of_house</code>。接下来是使用 <code>pub</code> 标记的 <code>hosting</code> 模块。我们可以访问 <code>hosting</code> 的父模块，所以可以访问 <code>hosting</code>。最后，<code>add_to_waitlist</code> 函数被标记为 <code>pub</code> ，我们可以访问其父模块，所以这个函数调用是有效的！</p><p>在相对路径，其逻辑与绝对路径相同，除了第一步：不同于从 crate 根开始，路径从 <code>front_of_house</code> 开始。<code>front_of_house</code> 模块与 <code>eat_at_restaurant</code> 定义于同一模块，所以从 <code>eat_at_restaurant</code> 中开始定义的该模块相对路径是有效的。接下来因为 <code>hosting</code> 和 <code>add_to_waitlist</code> 被标记为 <code>pub</code>，路径其余的部分也是有效的，因此函数调用也是有效的！</p><p>如果你计划共享你的库 crate 以便其它项目可以使用你的代码，公有 API 将是决定 crate 用户如何与你代码交互的契约。关于管理公有 API 的修改以便被人更容易依赖你的库有着很多考量。这些考量超出了本书的范畴；如果你对这些话题感兴趣，请查阅 <a href="https://rust-lang.github.io/api-guidelines/" target="_blank" rel="noopener noreferrer">The Rust API Guidelines</a></p>',31)),o("blockquote",null,[e[16]||(e[16]=o("h3",{id:"二进制和库-crate-包的最佳实践",tabindex:"-1"},"二进制和库 crate 包的最佳实践",-1)),e[17]||(e[17]=o("p",null,[t("我们提到过包（package）可以同时包含一个 "),o("em",null,"src/main.rs"),t(" 二进制 crate 根和一个 "),o("em",null,"src/lib.rs"),t(" 库 crate 根，并且这两个 crate 默认以包名来命名。通常，这种包含二进制 crate 和库 crate 的模式的包，在二进制 crate 中只保留足以生成一个可执行文件的代码，并由可执行文件调用库 crate 的代码。又因为库 crate 可以共享，这使得其它项目从包提供的大部分功能中受益。")],-1)),e[18]||(e[18]=o("p",null,[t("模块树应该定义在 "),o("em",null,"src/lib.rs"),t(" 中。这样通过以包名开头的路径，公有项就可以在二进制 crate 中使用。二进制 crate 就变得同其它在该 crate 之外的、使用库 crate 的用户一样：二者都只能使用公有 API。这有助于你设计一个好的 API；你不仅仅是作者，也是用户！")],-1)),o("p",null,[e[14]||(e[14]=t("在")),i(s,{to:"/ch12-00-an-io-project.html"},{default:a(()=>e[13]||(e[13]=[t("第十二章")])),_:1}),e[15]||(e[15]=t("我们会通过一个同时包含二进制 crate 和库 crate 的命令行程序来展示这些包组织上的实践。"))])]),e[21]||(e[21]=d('<h3 id="super-开始的相对路径" tabindex="-1"><code>super</code> 开始的相对路径</h3><p>我们可以通过在路径的开头使用 <code>super</code> ，从父模块开始构建相对路径，而不是从当前模块或者 crate 根开始。这类似以 <code>..</code> 语法开始一个文件系统路径。使用 <code>super</code> 允许我们引用父模块中的已知项，这使得重新组织模块树变得更容易 —— 当模块与父模块关联的很紧密，但某天父模块可能要移动到模块树的其它位置。</p><p>考虑一下示例 7-8 中的代码，它模拟了厨师更正了一个错误订单，并亲自将其提供给客户的情况。<code>back_of_house</code> 模块中的定义的 <code>fix_incorrect_order</code> 函数通过指定的 <code>super</code> 起始的 <code>deliver_order</code> 路径，来调用父模块中的 <code>deliver_order</code> 函数：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground,test_harness line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,test_harness" data-title="rust,noplayground,test_harness" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-8: 使用以 <code>super</code> 开头的相对路径从父目录开始调用函数</span></p><p><code>fix_incorrect_order</code> 函数在 <code>back_of_house</code> 模块中，所以我们可以使用 <code>super</code> 进入 <code>back_of_house</code> 父模块，也就是本例中的 <code>crate</code> 根。在这里，我们可以找到 <code>deliver_order</code>。成功！我们认为 <code>back_of_house</code> 模块和 <code>deliver_order</code> 函数之间可能具有某种关联关系，并且，如果我们要重新组织这个 crate 的模块树，需要一起移动它们。因此，我们使用 <code>super</code>，这样一来，如果这些代码被移动到了其他模块，我们只需要更新很少的代码。</p><h3 id="创建公有的结构体和枚举" tabindex="-1">创建公有的结构体和枚举</h3><p>我们还可以使用 <code>pub</code> 来设计公有的结构体和枚举，不过关于在结构体和枚举上使用 <code>pub</code> 还有一些额外的细节需要注意。如果我们在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。我们可以根据情况决定每个字段是否公有。在示例 7-9 中，我们定义了一个公有结构体 <code>back_of_house::Breakfast</code>，其中有一个公有字段 <code>toast</code> 和私有字段 <code>seasonal_fruit</code>。这个例子模拟的情况是，在一家餐馆中，顾客可以选择随餐附赠的面包类型，但是厨师会根据季节和库存情况来决定随餐搭配的水果。餐馆可用的水果变化是很快的，所以顾客不能选择水果，甚至无法看到他们将会得到什么水果。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-9: 带有公有和私有字段的结构体</span></p><p>因为 <code>back_of_house::Breakfast</code> 结构体的 <code>toast</code> 字段是公有的，所以我们可以在 <code>eat_at_restaurant</code> 中使用点号来随意的读写 <code>toast</code> 字段。注意，我们不能在 <code>eat_at_restaurant</code> 中使用 <code>seasonal_fruit</code> 字段，因为 <code>seasonal_fruit</code> 是私有的。尝试去除那一行修改 <code>seasonal_fruit</code> 字段值的代码的注释，看看你会得到什么错误！</p><p>还请注意一点，因为 <code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造 <code>Breakfast</code> 的实例 (这里我们命名为 <code>summer</code>)。如果 <code>Breakfast</code> 没有这样的函数，我们将无法在 <code>eat_at_restaurant</code> 中创建 <code>Breakfast</code> 实例，因为我们不能在 <code>eat_at_restaurant</code> 中设置私有字段 <code>seasonal_fruit</code> 的值。</p><p>与之相反，如果我们将枚举设为公有，则它的所有成员都将变为公有。我们只需要在 <code>enum</code> 关键字前面加上 <code>pub</code>，就像示例 7-10 展示的那样。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-10: 设计公有枚举，使其所有成员公有</span></p><p>因为我们创建了名为 <code>Appetizer</code> 的公有枚举，所以我们可以在 <code>eat_at_restaurant</code> 中使用 <code>Soup</code> 和 <code>Salad</code> 成员。</p><p>如果枚举成员不是公有的，那么枚举会显得用处不大；给枚举的所有成员挨个添加 <code>pub</code> 是很令人恼火的，因此枚举成员默认就是公有的。结构体通常使用时，不必将它们的字段公有化，因此结构体遵循常规，内容全部是私有的，除非使用 <code>pub</code> 关键字。</p><p>还有一种使用 <code>pub</code> 的场景我们还没有涉及到，那就是我们最后要讲的模块功能：<code>use</code> 关键字。我们将先单独介绍 <code>use</code>，然后展示如何结合使用 <code>pub</code> 和 <code>use</code>。</p>',21))])}const m=r(p,[["render",u],["__file","ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html.vue"]]),b=JSON.parse('{"path":"/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html","title":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree","lang":"zh-CN","frontmatter":{"description":"引用模块项目的路径 ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md commit 2b4565662d1a7973d870744a923f58f8f7dcce91 来看一下 Rust 如何在模块树中找到一个项的位置，我们使用路径的方式，就像在文件系统使用路径一样。为了调用一个函数...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"引用模块项目的路径 ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md commit 2b4565662d1a7973d870744a923f58f8f7dcce91 来看一下 Rust 如何在模块树中找到一个项的位置，我们使用路径的方式，就像在文件系统使用路径一样。为了调用一个函数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":11.84,"words":3551},"filePathRelative":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","excerpt":"<h2>引用模块项目的路径</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md</a><br>\\n<br><br>\\ncommit 2b4565662d1a7973d870744a923f58f8f7dcce91</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","value":{"title":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree","path":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md"},{"source":"SUMMARY.md","target":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md"}]}}}');export{m as comp,b as data};
