import{_ as l,e as t,j as n,f as s,i as e,g as d,h as o,r,o as c}from"./app-BUAJ0pNw.js";const p={};function h(k,i){const a=r("RouteLink");return c(),t("div",null,[i[9]||(i[9]=n(`<h2 id="附录-a-关键字" tabindex="-1">附录 A：关键字</h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/appendix-01-keywords.md" target="_blank" rel="noopener noreferrer">appendix-01-keywords.md</a><br><br><br> commit efbafdba3618487fbc9305318fcab9775132ac15</p></blockquote><p>下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了 “<a href="#%E5%8E%9F%E5%A7%8B%E6%A0%87%E8%AF%86%E7%AC%A6">原始标识符</a>” 部分介绍的原始标识符），这包括函数、变量、参数、结构体字段、模块、crate、常量、宏、静态值、属性、类型、trait 或生命周期<br> 的名字。</p><h3 id="目前正在使用的关键字" tabindex="-1">目前正在使用的关键字</h3><p>如下关键字目前有对应其描述的功能。</p><ul><li><code>as</code> - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 <code>use</code> 语句中的项重命名</li><li><code>async</code> - 返回一个 <code>Future</code> 而不是阻塞当前线程</li><li><code>await</code> - 暂停执行直到 <code>Future</code> 的结果就绪</li><li><code>break</code> - 立刻退出循环</li><li><code>const</code> - 定义常量或不变裸指针（constant raw pointer）</li><li><code>continue</code> - 继续进入下一次循环迭代</li><li><code>crate</code> - 在模块路径中，代指 crate root</li><li><code>dyn</code> - 动态分发 trait 对象</li><li><code>else</code> - 作为 <code>if</code> 和 <code>if let</code> 控制流结构的 fallback</li><li><code>enum</code> - 定义一个枚举</li><li><code>extern</code> - 链接一个外部函数或变量</li><li><code>false</code> - 布尔字面值 <code>false</code></li><li><code>fn</code> - 定义一个函数或 <strong>函数指针类型</strong> (<em>function pointer type</em>)</li><li><code>for</code> - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期</li><li><code>if</code> - 基于条件表达式的结果分支</li><li><code>impl</code> - 实现自有或 trait 功能</li><li><code>in</code> - <code>for</code> 循环语法的一部分</li><li><code>let</code> - 绑定一个变量</li><li><code>loop</code> - 无条件循环</li><li><code>match</code> - 模式匹配</li><li><code>mod</code> - 定义一个模块</li><li><code>move</code> - 使闭包获取其所捕获项的所有权</li><li><code>mut</code> - 表示引用、裸指针或模式绑定的可变性</li><li><code>pub</code> - 表示结构体字段、<code>impl</code> 块或模块的公有可见性</li><li><code>ref</code> - 通过引用绑定</li><li><code>return</code> - 从函数中返回</li><li><code>Self</code> - 定义或实现 trait 的类型的类型别名</li><li><code>self</code> - 表示方法本身或当前模块</li><li><code>static</code> - 表示全局变量或在整个程序执行期间保持其生命周期</li><li><code>struct</code> - 定义一个结构体</li><li><code>super</code> - 表示当前模块的父模块</li><li><code>trait</code> - 定义一个 trait</li><li><code>true</code> - 布尔字面值 <code>true</code></li><li><code>type</code> - 定义一个类型别名或关联类型</li><li><code>union</code> - 定义一个 <a href="https://doc.rust-lang.org/reference/items/unions.html" target="_blank" rel="noopener noreferrer">union</a> 并且是 union 声明中唯一用到的关键字</li><li><code>unsafe</code> - 表示不安全的代码、函数、trait 或实现</li><li><code>use</code> - 引入外部空间的符号</li><li><code>where</code> - 表示一个约束类型的从句</li><li><code>while</code> - 基于一个表达式的结果判断是否进行循环</li></ul><h3 id="保留做将来使用的关键字" tabindex="-1">保留做将来使用的关键字</h3><p>如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。</p><ul><li><code>abstract</code></li><li><code>become</code></li><li><code>box</code></li><li><code>do</code></li><li><code>final</code></li><li><code>macro</code></li><li><code>override</code></li><li><code>priv</code></li><li><code>try</code></li><li><code>typeof</code></li><li><code>unsized</code></li><li><code>virtual</code></li><li><code>yield</code></li></ul><h3 id="原始标识符" tabindex="-1">原始标识符</h3><p>原始标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 <code>r#</code> 前缀。</p><p>例如，<code>match</code> 是关键字。如果尝试编译如下使用 <code>match</code> 作为名字的函数：</p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {</span></span>
<span class="line"><span>    haystack.contains(needle)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会得到这个错误：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>error: expected identifier, found keyword \`match\`</span></span>
<span class="line"><span> --&gt; src/main.rs:4:4</span></span>
<span class="line"><span>  |</span></span>
<span class="line"><span>4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {</span></span>
<span class="line"><span>  |    ^^^^^ expected identifier, found keyword</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该错误表示你不能将关键字 <code>match</code> 用作函数标识符。你可以使用原始标识符将 <code>match</code> 作为函数名称使用：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> r#match</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">needle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">haystack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    haystack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">contains</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">needle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    assert!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">r#match</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foobar&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此代码编译没有任何错误。注意 <code>r#</code> 前缀需同时用于函数名定义和 <code>main</code> 函数中的调用。</p>`,19)),s("p",null,[i[1]||(i[1]=e("原始标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。这给予了我们更大的自由来选择名字，这样与其他语言交互式就不用考虑到关键字问题，在要交互的语言中这个名字不是关键字。此外，原始标识符允许你使用以不同于你的 crate 使用的 Rust 版本编写的库。比如，")),i[2]||(i[2]=s("code",null,"try",-1)),i[3]||(i[3]=e(" 在 2015 edition 中不是关键字，而在 2018 edition 则是。所以如果用 2015 edition 编写的库中带有 ")),i[4]||(i[4]=s("code",null,"try",-1)),i[5]||(i[5]=e(" 函数，在 2018 edition 中调用时就需要使用原始标识符语法，在这里是 ")),i[6]||(i[6]=s("code",null,"r#try",-1)),i[7]||(i[7]=e("。有关版本的更多信息，请参见")),d(a,{to:"/appendix-05-editions.html"},{default:o(()=>i[0]||(i[0]=[e("附录 E")])),_:1}),i[8]||(i[8]=e("。"))])])}const u=l(p,[["render",h],["__file","appendix-01-keywords.html.vue"]]),b=JSON.parse('{"path":"/appendix-01-keywords.html","title":"appendix-01-keywords","lang":"zh-CN","frontmatter":{"description":"附录 A：关键字 appendix-01-keywords.md commit efbafdba3618487fbc9305318fcab9775132ac15 下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了 “原始标识符” 部分介绍的原始标识符），这包括函数、变量、参数、结构体字段、模块、crate...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/appendix-01-keywords.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"附录 A：关键字 appendix-01-keywords.md commit efbafdba3618487fbc9305318fcab9775132ac15 下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了 “原始标识符” 部分介绍的原始标识符），这包括函数、变量、参数、结构体字段、模块、crate..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"git":{},"readingTime":{"minutes":3.62,"words":1087},"filePathRelative":"appendix-01-keywords.md","excerpt":"<h2>附录 A：关键字</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/appendix-01-keywords.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">appendix-01-keywords.md</a><br>\\n<br><br>\\ncommit efbafdba3618487fbc9305318fcab9775132ac15</p>\\n</blockquote>\\n<p>下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了 “<a href=\\"#%E5%8E%9F%E5%A7%8B%E6%A0%87%E8%AF%86%E7%AC%A6\\">原始标识符</a>” 部分介绍的原始标识符），这包括函数、变量、参数、结构体字段、模块、crate、常量、宏、静态值、属性、类型、trait 或生命周期<br>\\n的名字。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"appendix-01-keywords.md","value":{"title":"appendix-01-keywords","path":"appendix-01-keywords.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"appendix-01-keywords.md"},{"source":"SUMMARY.md","target":"appendix-01-keywords.md"}]}}}');export{u as comp,b as data};
