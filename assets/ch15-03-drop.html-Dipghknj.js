import{_ as o,e as d,j as t,o as i}from"./app-jlAZUEML.js";const r={};function s(c,e){return i(),d("div",null,e[0]||(e[0]=[t('<h2 id="使用-drop-trait-运行清理代码" tabindex="-1"><a class="header-anchor" href="#使用-drop-trait-运行清理代码"><span>使用 <code>Drop</code> Trait 运行清理代码</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch15-03-drop.md" target="_blank" rel="noopener noreferrer">ch15-03-drop.md</a><br><br><br> commit 5a3a64d60b0dd786c35ca4daada7a4d20da33e5e</p></blockquote><p>对于智能指针模式来说第二个重要的 trait 是 <code>Drop</code>，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 <code>Drop</code> trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。</p><p>我们在智能指针上下文中讨论 <code>Drop</code> 是因为其功能几乎总是用于实现智能指针。例如，当 <code>Box&lt;T&gt;</code> 被丢弃时会释放 box 指向的堆空间。</p><p>在其他一些语言中的某些类型，我们不得不记住在每次使用完那些类型的智能指针实例后调用清理内存或资源的代码。如果忘记的话，运行代码的系统可能会因为负荷过重而崩溃。在 Rust 中，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。于是我们就不需要在程序中到处编写在实例结束时清理这些变量的代码 —— 而且还不会泄漏资源。</p><p>指定在值离开作用域时应该执行的代码的方式是实现 <code>Drop</code> trait。<code>Drop</code> trait 要求实现一个叫做 <code>drop</code> 的方法，它获取一个 <code>self</code> 的可变引用。为了能够看出 Rust 何时调用 <code>drop</code>，让我们暂时使用 <code>println!</code> 语句实现 <code>drop</code>。</p><p>示例 15-14 展示了唯一定制功能就是当其实例离开作用域时，打印出 <code>Dropping CustomSmartPointer!</code> 的结构体 <code>CustomSmartPointer</code>，这会演示 Rust 何时运行 <code>drop</code> 函数：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-14/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 15-14：结构体 <code>CustomSmartPointer</code>，其实现了放置清理代码的 <code>Drop</code> trait</span></p><p><code>Drop</code> trait 包含在 prelude 中，所以无需导入它。我们在 <code>CustomSmartPointer</code> 上实现了 <code>Drop</code> trait，并提供了一个调用 <code>println!</code> 的 <code>drop</code> 方法实现。<code>drop</code> 函数体是放置任何当类型实例离开作用域时期望运行的逻辑的地方。这里选择打印一些文本以可视化地展示 Rust 何时调用 <code>drop</code>。</p><p>在 <code>main</code> 中，我们新建了两个 <code>CustomSmartPointer</code> 实例并打印出了 <code>CustomSmartPointer created.</code>。在 <code>main</code> 的结尾，<code>CustomSmartPointer</code> 的实例会离开作用域，而 Rust 会调用放置于 <code>drop</code> 方法中的代码，打印出最后的信息。注意无需显式调用 <code>drop</code> 方法：</p><p>当运行这个程序，会出现如下输出：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch15-smart-pointers/listing-15-14/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当实例离开作用域 Rust 会自动调用 <code>drop</code>，并调用我们指定的代码。变量以被创建时相反的顺序被丢弃，所以 <code>d</code> 在 <code>c</code> 之前被丢弃。这个例子的作用是给了我们一个 drop 方法如何工作的可视化指导，不过通常需要指定类型所需执行的清理代码而不是打印信息。</p><h4 id="通过-std-mem-drop-提早丢弃值" tabindex="-1"><a class="header-anchor" href="#通过-std-mem-drop-提早丢弃值"><span>通过 <code>std::mem::drop</code> 提早丢弃值</span></a></h4><p>不幸的是，我们并不能直截了当的禁用 <code>drop</code> 这个功能。通常也不需要禁用 <code>drop</code> ；整个 <code>Drop</code> trait 存在的意义在于其是自动处理的。然而，有时你可能需要提早清理某个值。一个例子是当使用智能指针管理锁时；你可能希望强制运行 <code>drop</code> 方法来释放锁以便作用域中的其他代码可以获取锁。Rust 并不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法；当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>。</p><p>如果我们像是示例 15-14 那样尝试调用 <code>Drop</code> trait 的 <code>drop</code> 方法，就会得到像示例 15-15 那样的编译错误：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-15/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 15-15：尝试手动调用 <code>Drop</code> trait 的 <code>drop</code> 方法提早清理</span></p><p>如果尝试编译代码会得到如下错误：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch15-smart-pointers/listing-15-15/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>错误信息表明不允许显式调用 <code>drop</code>。错误信息使用了术语 <strong>析构函数</strong>（<em>destructor</em>），这是一个清理实例的函数的通用编程概念。<strong>析构函数</strong> 对应创建实例的 <strong>构造函数</strong>。Rust 中的 <code>drop</code> 函数就是这么一个析构函数。</p><p>Rust 不允许我们显式调用 <code>drop</code> 因为 Rust 仍然会在 <code>main</code> 的结尾对值自动调用 <code>drop</code>，这会导致一个 <em>double free</em> 错误，因为 Rust 会尝试清理相同的值两次。</p><p>因为不能禁用当值离开作用域时自动插入的 <code>drop</code>，并且不能显式调用 <code>drop</code>，如果我们需要强制提早清理值，可以使用 <code>std::mem::drop</code> 函数。</p><p><code>std::mem::drop</code> 函数不同于 <code>Drop</code> trait 中的 <code>drop</code> 方法。可以通过传递希望强制丢弃的值作为参数。<code>std::mem::drop</code> 位于 prelude，所以我们可以修改示例 15-15 中的 <code>main</code> 来调用 <code>drop</code> 函数。如示例 15-16 所示：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-16/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 15-16: 在值离开作用域之前调用 <code>std::mem::drop</code> 显式清理</span></p><p>运行这段代码会打印出如下：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch15-smart-pointers/listing-15-16/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>Dropping CustomSmartPointer with data `some data`!</code> 出现在 <code>CustomSmartPointer created.</code> 和 <code>CustomSmartPointer dropped before the end of main.</code> 之间，表明了 <code>drop</code> 方法被调用了并在此丢弃了 <code>c</code>。</p><p><code>Drop</code> trait 实现中指定的代码可以用于许多方面，来使得清理变得方便和安全：比如可以用其创建我们自己的内存分配器！通过 <code>Drop</code> trait 和 Rust 所有权系统，你无需担心之后的代码清理，Rust 会自动考虑这些问题。</p><p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 <code>drop</code> 只会在值不再被使用时被调用一次。</p><p>现在我们学习了 <code>Box&lt;T&gt;</code> 和一些智能指针的特性，让我们聊聊标准库中定义的其他几种智能指针。</p>',36)]))}const n=o(r,[["render",s],["__file","ch15-03-drop.html.vue"]]),p=JSON.parse('{"path":"/ch15-03-drop.html","title":"ch15-03-drop","lang":"zh-CN","frontmatter":{"description":"使用 Drop Trait 运行清理代码 ch15-03-drop.md commit 5a3a64d60b0dd786c35ca4daada7a4d20da33e5e 对于智能指针模式来说第二个重要的 trait 是 Drop，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch15-03-drop.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"使用 Drop Trait 运行清理代码 ch15-03-drop.md commit 5a3a64d60b0dd786c35ca4daada7a4d20da33e5e 对于智能指针模式来说第二个重要的 trait 是 Drop，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":5.19,"words":1557},"filePathRelative":"ch15-03-drop.md","excerpt":"<h2>使用 <code>Drop</code> Trait 运行清理代码</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch15-03-drop.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch15-03-drop.md</a><br>\\n<br><br>\\ncommit 5a3a64d60b0dd786c35ca4daada7a4d20da33e5e</p>\\n</blockquote>\\n<p>对于智能指针模式来说第二个重要的 trait 是 <code>Drop</code>，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 <code>Drop</code> trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch15-03-drop.md","value":{"title":"ch15-03-drop","path":"ch15-03-drop.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch15-03-drop.md"},{"source":"SUMMARY.md","target":"ch15-03-drop.md"}]}}}');export{n as comp,p as data};
