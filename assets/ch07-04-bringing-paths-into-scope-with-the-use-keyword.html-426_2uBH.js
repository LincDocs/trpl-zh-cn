import{_ as n,c as d,e as a,a as i,d as s,b as o,w as r,r as c,o as l}from"./app-tYpKMo5U.js";const p={};function h(g,e){const t=c("RouteLink");return l(),d("div",null,[e[7]||(e[7]=a('<h2 id="使用-use-关键字将路径引入作用域" tabindex="-1">使用 <code>use</code> 关键字将路径引入作用域</h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md" target="_blank" rel="noopener noreferrer">ch07-04-bringing-paths-into-scope-with-the-use-keyword.md</a><br><br><br> commit c77d7a1279dbc7a9d76e80c5ac9d742dd529538c</p></blockquote><p>不得不编写路径来调用函数显得不便且重复。在示例 7-7 中，无论我们选择 <code>add_to_waitlist</code> 函数的绝对路径还是相对路径，每次我们想要调用 <code>add_to_waitlist</code> 时，都必须指定<code>front_of_house</code> 和 <code>hosting</code>。幸运的是，有一种方法可以简化这个过程。我们可以使用 <code>use</code> 关键字创建一个短路径，然后就可以在作用域中的任何地方使用这个更短的名字。</p><p>在示例 7-11 中，我们将 <code>crate::front_of_house::hosting</code> 模块引入了 <code>eat_at_restaurant</code> 函数的作用域，而我们只需要指定 <code>hosting::add_to_waitlist</code> 即可在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground,test_harness line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,test_harness" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground,test_harness"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-11/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-11: 使用 <code>use</code> 将模块引入作用域</span></p><p>在作用域中增加 <code>use</code> 和路径类似于在文件系统中创建软连接（符号连接，symbolic link）。通过在 crate 根增加 <code>use crate::front_of_house::hosting</code>，现在 <code>hosting</code> 在作用域中就是有效的名称了，如同 <code>hosting</code> 模块被定义于 crate 根一样。通过 <code>use</code> 引入作用域的路径也会检查私有性，同其它路径一样。</p><p>注意 <code>use</code> 只能创建 <code>use</code> 所在的特定作用域内的短路径。示例 7-12 将 <code>eat_at_restaurant</code> 函数移动到了一个叫 <code>customer</code> 的子模块，这又是一个不同于 <code>use</code> 语句的作用域，所以函数体不能编译。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground,test_harness,does_not_compile,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,test_harness,does_not_compile,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground,test_harness,does_not_compile,ignore"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-12/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-12: <code>use</code> 语句只适用于其所在的作用域</span></p><p>编译器错误显示短路径不再适用于 <code>customer</code> 模块中：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-console"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch07-managing-growing-projects/listing-07-12/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意这里还有一个警告说 <code>use</code> 在其作用域内不再被使用！为了修复这个问题，可以将 <code>use</code> 移动到 <code>customer</code> 模块内，或者在子模块 <code>customer</code> 内通过 <code>super::hosting</code> 引用父模块中的这个短路径。</p><h3 id="创建惯用的-use-路径" tabindex="-1">创建惯用的 <code>use</code> 路径</h3><p>在示例 7-11 中，你可能会比较疑惑，为什么我们是指定 <code>use crate::front_of_house::hosting</code> ，然后在 <code>eat_at_restaurant</code> 中调用 <code>hosting::add_to_waitlist</code> ，而不是通过指定一直到 <code>add_to_waitlist</code> 函数的 <code>use</code> 路径来得到相同的结果，如示例 7-13 所示。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground,test_harness line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,test_harness" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground,test_harness"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-13/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-13: 使用 <code>use</code> 将 <code>add_to_waitlist</code> 函数引入作用域，这并不符合习惯</span></p><p>虽然示例 7-11 和 7-13 都完成了相同的任务，但示例 7-11 是使用 <code>use</code> 将函数引入作用域的习惯用法。要想使用 <code>use</code> 将函数的父模块引入作用域，我们必须在调用函数时指定父模块，这样可以清晰地表明函数不是在本地定义的，同时使完整路径的重复度最小化。示例 7-13 中的代码不清楚 <code>add_to_waitlist</code> 是在哪里被定义的。</p><p>另一方面，使用 <code>use</code> 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。示例 7-14 展示了将 <code>HashMap</code> 结构体引入二进制 crate 作用域的习惯用法。</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-14/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-14: 将 <code>HashMap</code> 引入作用域的习惯用法</span></p><p>这种习惯用法背后没有什么硬性要求：它只是一种惯例，人们已经习惯了以这种方式阅读和编写 Rust 代码。</p><p>这个习惯用法有一个例外，那就是我们想使用 <code>use</code> 语句将两个具有相同名称的项带入作用域，因为 Rust 不允许这样做。示例 7-15 展示了如何将两个具有相同名称但不同父模块的 <code>Result</code> 类型引入作用域，以及如何引用它们。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-15/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-15: 使用父模块将两个具有相同名称的类型引入同一作用域</span></p><p>如你所见，使用父模块可以区分这两个 <code>Result</code> 类型。如果我们是指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，我们将在同一作用域拥有了两个 <code>Result</code> 类型，当我们使用 <code>Result</code> 时，Rust 则不知道我们要用的是哪个。</p><h3 id="使用-as-关键字提供新的名称" tabindex="-1">使用 <code>as</code> 关键字提供新的名称</h3><p>使用 <code>use</code> 将两个同名类型引入同一作用域这个问题还有另一个解决办法：在这个类型的路径后面，我们使用 <code>as</code> 指定一个新的本地名称或者别名。示例 7-16 展示了另一个编写示例 7-15 中代码的方法，通过 <code>as</code> 重命名其中一个 <code>Result</code> 类型。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-16/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-16: 使用 <code>as</code> 关键字重命名引入作用域的类型</span></p><p>在第二个 <code>use</code> 语句中，我们选择 <code>IoResult</code> 作为 <code>std::io::Result</code> 的新名称，它与从 <code>std::fmt</code> 引入作用域的 <code>Result</code> 并不冲突。示例 7-15 和示例 7-16 都是惯用的，如何选择都取决于你！</p><h3 id="使用-pub-use-重导出名称" tabindex="-1">使用 <code>pub use</code> 重导出名称</h3><p>使用 <code>use</code> 关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外还是私有的。如果想让其他人调用我们的代码时，也能够正常使用这个名称，就好像它本来就在当前作用域一样，那我们可以将 <code>pub</code> 和 <code>use</code> 合起来使用。这种技术被称为 “<em>重导出</em>（<em>re-exporting</em>）”：我们不仅将一个名称导入了当前作用域，还允许别人把它导入他们自己的作用域。</p><p>示例 7-17 将示例 7-11 根模块中的 <code>use</code> 改为 <code>pub use</code> 。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground,test_harness line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,test_harness" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground,test_harness"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-17/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-17: 通过 <code>pub use</code> 使名称可从新作用域中被导入至任何代码</span></p><p>在这个修改之前，外部代码需要使用路径 <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> 来调用 <code>add_to_waitlist</code> 函数。现在这个 <code>pub use</code> 从根模块重导出了 <code>hosting</code> 模块，外部代码现在可以使用路径 <code>restaurant::hosting::add_to_waitlist</code>。</p>',44)),i("p",null,[e[1]||(e[1]=s("当你代码的内部结构与调用你代码的程序员所想象的结构不同时，重导出会很有用。例如，在这个餐馆的比喻中，经营餐馆的人会想到“前台”和“后台”。但顾客在光顾一家餐馆时，可能不会以这些术语来考虑餐馆的各个部分。使用 ")),e[2]||(e[2]=i("code",null,"pub use",-1)),e[3]||(e[3]=s("，我们可以使用一种结构编写代码，却将不同的结构形式暴露出来。这样做使我们的库井井有条，也使开发这个库的程序员和调用这个库的程序员都更加方便。在")),o(t,{to:"/ch14-02-publishing-to-crates-io.html#%E4%BD%BF%E7%94%A8-pub-use-%E5%AF%BC%E5%87%BA%E5%90%88%E9%80%82%E7%9A%84%E5%85%AC%E6%9C%89-api"},{default:r(()=>e[0]||(e[0]=[s("“使用 "),i("code",null,"pub use",-1),s(" 导出合适的公有 API”")])),_:1,__:[0]}),e[4]||(e[4]=s("部分让我们再看另一个 ")),e[5]||(e[5]=i("code",null,"pub use",-1)),e[6]||(e[6]=s(" 的例子来了解这如何影响 crate 的文档。"))]),e[8]||(e[8]=a('<h3 id="使用外部包" tabindex="-1">使用外部包</h3><p>在第二章中我们编写了一个猜猜看游戏。那个项目使用了一个外部包，<code>rand</code>，来生成随机数。为了在项目中使用 <code>rand</code>，在 <em>Cargo.toml</em> 中加入了如下行：</p><p><span class="filename">文件名：Cargo.toml</span></p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-toml"><span class="line"><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:9:}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 <em>Cargo.toml</em> 中加入 <code>rand</code> 依赖告诉了 Cargo 要从 <a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a> 下载 <code>rand</code> 和其依赖，并使其可在项目代码中使用。</p><p>接着，为了将 <code>rand</code> 定义引入项目包的作用域，我们加入一行 <code>use</code> 起始的包名，它以 <code>rand</code> 包名开头并列出了需要引入作用域的项。回忆一下第二章的 “生成一个随机数” 部分，我们曾将 <code>Rng</code> trait 引入作用域并调用了 <code>rand::thread_rng</code> 函数：</p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,ignore"><span class="line"><span>{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:ch07-04}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a> 上有很多 Rust 社区成员发布的包，将其引入你自己的项目都需要一道相同的步骤：在 <em>Cargo.toml</em> 列出它们并通过 <code>use</code> 将其中定义的项引入项目包的作用域中。</p><p>注意 <code>std</code> 标准库对于你的包来说也是外部 crate。因为标准库随 Rust 语言一同分发，无需修改 <em>Cargo.toml</em> 来引入 <code>std</code>，不过需要通过 <code>use</code> 将标准库中定义的项引入项目包的作用域中来引用它们，比如我们使用的 <code>HashMap</code>：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">collections</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是一个以标准库 crate 名 <code>std</code> 开头的绝对路径。</p><h3 id="嵌套路径来消除大量的-use-行" tabindex="-1">嵌套路径来消除大量的 <code>use</code> 行</h3><p>当需要引入很多定义于相同包或相同模块的项时，为每一项单独列出一行会占用源码很大的空间。例如猜猜看章节示例 2-4 中有两行 <code>use</code> 语句都从 <code>std</code> 引入项到作用域：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,ignore"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-01-use-std-unnested/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>相反，我们可以使用嵌套路径将相同的项在一行中引入作用域。这么做需要指定路径的相同部分，接着是两个冒号，接着是大括号中的各自不同的路径部分，如示例 7-18 所示。</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,ignore"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-18/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-18: 指定嵌套的路径在一行中将多个带有相同前缀的项引入作用域</span></p><p>在较大的程序中，使用嵌套路径从相同包或模块中引入很多项，可以显著减少所需的独立 <code>use</code> 语句的数量！</p><p>我们可以在路径的任何层级使用嵌套路径，这在组合两个共享子路径的 <code>use</code> 语句时非常有用。例如，示例 7-19 中展示了两个 <code>use</code> 语句：一个将 <code>std::io</code> 引入作用域，另一个将 <code>std::io::Write</code> 引入作用域：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-19/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-19: 通过两行 <code>use</code> 语句引入两个路径，其中一个是另一个的子路径</span></p><p>两个路径的相同部分是 <code>std::io</code>，这正是第一个路径。为了在一行 <code>use</code> 语句中引入这两个路径，可以在嵌套路径中使用 <code>self</code>，如示例 7-20 所示。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust,noplayground"><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-20/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-20: 将示例 7-19 中部分重复的路径合并为一个 <code>use</code> 语句</span></p><p>这一行便将 <code>std::io</code> 和 <code>std::io::Write</code> 同时引入作用域。</p><h3 id="通过-glob-运算符将所有的公有定义引入作用域" tabindex="-1">通过 glob 运算符将所有的公有定义引入作用域</h3><p>如果希望将一个路径下 <strong>所有</strong> 公有项引入作用域，可以指定路径后跟 <code>*</code>，glob 运算符：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">collections</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::*;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个 <code>use</code> 语句将 <code>std::collections</code> 中定义的所有公有项引入当前作用域。使用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。</p><p>glob 运算符经常用于测试模块 <code>tests</code> 中，这时会将所有内容引入作用域；我们将在第十一章 “如何编写测试” 部分讲解。glob 运算符有时也用于 prelude 模式；查看 <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes" target="_blank" rel="noopener noreferrer">标准库中的文档</a> 了解这个模式的更多细节。</p>',34))])}const k=n(p,[["render",h]]),b=JSON.parse('{"path":"/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html","title":"ch07-04-bringing-paths-into-scope-with-the-use-keyword","lang":"zh-CN","frontmatter":{"description":"使用 use 关键字将路径引入作用域 ch07-04-bringing-paths-into-scope-with-the-use-keyword.md commit c77d7a1279dbc7a9d76e80c5ac9d742dd529538c 不得不编写路径来调用函数显得不便且重复。在示例 7-7 中，无论我们选择 add_to_waitlist...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"使用 use 关键字将路径引入作用域 ch07-04-bringing-paths-into-scope-with-the-use-keyword.md commit c77d7a1279dbc7a9d76e80c5ac9d742dd529538c 不得不编写路径来调用函数显得不便且重复。在示例 7-7 中，无论我们选择 add_to_waitlist..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":9.86,"words":2958},"filePathRelative":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","excerpt":"<h2>使用 <code>use</code> 关键字将路径引入作用域</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch07-04-bringing-paths-into-scope-with-the-use-keyword.md</a><br>\\n<br><br>\\ncommit c77d7a1279dbc7a9d76e80c5ac9d742dd529538c</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","value":{"title":"ch07-04-bringing-paths-into-scope-with-the-use-keyword","path":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md"},{"source":"SUMMARY.md","target":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md"}]}}}');export{k as comp,b as data};
