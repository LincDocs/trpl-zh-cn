import{_ as e,e as o,j as a,o as r}from"./app-DVGyNizL.js";const n={};function c(i,t){return r(),o("div",null,t[0]||(t[0]=[a('<h1 id="编写自动化测试" tabindex="-1"><a class="header-anchor" href="#编写自动化测试"><span>编写自动化测试</span></a></h1><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch11-00-testing.md" target="_blank" rel="noopener noreferrer">ch11-00-testing.md</a><br><br><br> commit 765318b844569a642ceef7bf1adab9639cbf6af3</p></blockquote><p>Edsger W. Dijkstra 在其 1972 年的文章【谦卑的程序员】（“The Humble Programmer”）中说到 “软件测试是证明 bug 存在的有效方法，而证明其不存在时则显得令人绝望的不足。”（“Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.”）这并不意味着我们不该尽可能地测试软件！</p><p>程序的正确性意味着代码如我们期望的那样运行。Rust 是一个相当注重正确性的编程语言，不过正确性是一个难以证明的复杂主题。Rust 的类型系统在此问题上下了很大的功夫，不过类型系统不可能捕获所有问题。为此，Rust 包含了编写自动化软件测试的功能支持。</p><p>假设我们可以编写一个叫做 <code>add_two</code> 的将传递给它的值加二的函数。它的签名有一个整型参数并返回一个整型值。当实现和编译这个函数时，Rust 会进行所有目前我们已经见过的类型检查和借用检查，例如，这些检查会确保我们不会传递 <code>String</code> 或无效的引用给这个函数。Rust 所 <strong>不能</strong> 检查的是这个函数是否会准确的完成我们期望的工作：返回参数加二后的值，而不是比如说参数加 10 或减 50 的值！这也就是测试出场的地方。</p><p>我们可以编写测试断言，比如说，当传递 <code>3</code> 给 <code>add_two</code> 函数时，返回值是 <code>5</code>。无论何时对代码进行修改，都可以运行测试来确保任何现存的正确行为没有被改变。</p><p>测试是一项复杂的技能：虽然不能在一个章节的篇幅中介绍如何编写好的测试的每个细节，但我们还是会讨论 Rust 测试功能的机制。我们会讲到编写测试时会用到的注解和宏，运行测试的默认行为和选项，以及如何将测试组织成单元测试和集成测试。</p>',7)]))}const l=e(n,[["render",c],["__file","ch11-00-testing.html.vue"]]),m=JSON.parse('{"path":"/ch11-00-testing.html","title":"编写自动化测试","lang":"zh-CN","frontmatter":{"description":"编写自动化测试 ch11-00-testing.md commit 765318b844569a642ceef7bf1adab9639cbf6af3 Edsger W. Dijkstra 在其 1972 年的文章【谦卑的程序员】（“The Humble Programmer”）中说到 “软件测试是证明 bug 存在的有效方法，而证明其不存在时则显得令人...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch11-00-testing.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:title","content":"编写自动化测试"}],["meta",{"property":"og:description","content":"编写自动化测试 ch11-00-testing.md commit 765318b844569a642ceef7bf1adab9639cbf6af3 Edsger W. Dijkstra 在其 1972 年的文章【谦卑的程序员】（“The Humble Programmer”）中说到 “软件测试是证明 bug 存在的有效方法，而证明其不存在时则显得令人..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编写自动化测试\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":1.85,"words":555},"filePathRelative":"ch11-00-testing.md","excerpt":"\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch11-00-testing.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch11-00-testing.md</a><br>\\n<br><br>\\ncommit 765318b844569a642ceef7bf1adab9639cbf6af3</p>\\n</blockquote>\\n<p>Edsger W. Dijkstra 在其 1972 年的文章【谦卑的程序员】（“The Humble Programmer”）中说到 “软件测试是证明 bug 存在的有效方法，而证明其不存在时则显得令人绝望的不足。”（“Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.”）这并不意味着我们不该尽可能地测试软件！</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch11-00-testing.md","value":{"title":"ch11-00-testing","path":"ch11-00-testing.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch11-00-testing.md"},{"source":"SUMMARY.md","target":"ch11-00-testing.md"}]}}}');export{l as comp,m as data};
