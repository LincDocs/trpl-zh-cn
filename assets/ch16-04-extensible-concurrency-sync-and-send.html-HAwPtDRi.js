import{_ as o,c as r,e as c,a as n,b as a,d,w as s,r as i,o as l}from"./app-CXbgoZN5.js";const p={};function u(m,e){const t=i("RouteLink");return l(),r("div",null,[e[3]||(e[3]=c('<h2 id="使用-sync-和-send-trait-的可扩展并发" tabindex="-1">使用 <code>Sync</code> 和 <code>Send</code> trait 的可扩展并发</h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch16-04-extensible-concurrency-sync-and-send.md" target="_blank" rel="noopener noreferrer">ch16-04-extensible-concurrency-sync-and-send.md</a><br><br><br> commit 7c7740a5ddef1458d74f1daf85fd49e03aaa97cf</p></blockquote><p>Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 <strong>甚少</strong>。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。</p><p>然而有两个并发概念是内嵌于语言中的：<code>std::marker</code> 中的 <code>Sync</code> 和 <code>Send</code> trait。</p><h3 id="通过-send-允许在线程间转移所有权" tabindex="-1">通过 <code>Send</code> 允许在线程间转移所有权</h3><p><code>Send</code> 标记 trait 表明实现了 <code>Send</code> 的类型值的所有权可以在线程间传送。几乎所有的 Rust 类型都是<code>Send</code> 的，不过有一些例外，包括 <code>Rc&lt;T&gt;</code>：这是不能 <code>Send</code> 的，因为如果克隆了 <code>Rc&lt;T&gt;</code> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，<code>Rc&lt;T&gt;</code> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。</p><p>因此，Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 <code>Rc&lt;T&gt;</code> 在线程间发送。当尝试在示例 16-14 中这么做的时候，会得到错误 <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>。而使用标记为 <code>Send</code> 的 <code>Arc&lt;T&gt;</code> 时，就没有问题了。</p><p>任何完全由 <code>Send</code> 的类型组成的类型也会自动被标记为 <code>Send</code>。几乎所有基本类型都是 <code>Send</code> 的，除了第二十章将会讨论的裸指针（raw pointer）。</p><h3 id="sync-允许多线程访问" tabindex="-1"><code>Sync</code> 允许多线程访问</h3><p><code>Sync</code> 标记 trait 表明一个实现了 <code>Sync</code> 的类型可以安全的在多个线程中拥有其值的引用。换一种方式来说，对于任意类型 <code>T</code>，如果 <code>&amp;T</code>（<code>T</code> 的不可变引用）是 <code>Send</code> 的话 <code>T</code> 就是 <code>Sync</code> 的，这意味着其引用就可以安全的发送到另一个线程。类似于 <code>Send</code> 的情况，基本类型是 <code>Sync</code> 的，完全由 <code>Sync</code> 的类型组成的类型也是 <code>Sync</code> 的。</p>',10)),n("p",null,[e[1]||(e[1]=c("智能指针 <code>Rc&lt;T&gt;</code> 也不是 <code>Sync</code> 的，出于其不是 <code>Send</code> 相同的原因。<code>RefCell&lt;T&gt;</code>（第十五章讨论过）和 <code>Cell&lt;T&gt;</code> 系列类型不是 <code>Sync</code> 的。<code>RefCell&lt;T&gt;</code> 在运行时所进行的借用检查也不是线程安全的。<code>Mutex&lt;T&gt;</code> 是 <code>Sync</code> 的，正如 ",19)),a(t,{to:"/ch16-03-shared-state.html#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB-mutext"},{default:s(()=>e[0]||(e[0]=[d("“在线程间共享 "),n("code",null,"Mutex<T>",-1),d("”")])),_:1,__:[0]}),e[2]||(e[2]=d(" 部分所讲的它可以被用来在多线程中共享访问。"))]),e[4]||(e[4]=c('<h3 id="手动实现-send-和-sync-是不安全的" tabindex="-1">手动实现 <code>Send</code> 和 <code>Sync</code> 是不安全的</h3><p>通常并不需要手动实现 <code>Send</code> 和 <code>Sync</code> trait，因为由 <code>Send</code> 和 <code>Sync</code> 的类型组成的类型，自动就是 <code>Send</code> 和 <code>Sync</code> 的。因为它们是标记 trait，甚至都不需要实现任何方法。它们只是用来加强并发相关的不可变性的。</p><p>手动实现这些标记 trait 涉及到编写不安全的 Rust 代码，第十九章将会讲述具体的方法；当前重要的是，在创建新的由不是 <code>Send</code> 和 <code>Sync</code> 的部分构成的并发类型时需要多加小心，以确保维持其安全保证。<a href="https://doc.rust-lang.org/nomicon/index.html" target="_blank" rel="noopener noreferrer">“The Rustonomicon”</a> 中有更多关于这些保证以及如何维持它们的信息。</p><h2 id="总结" tabindex="-1">总结</h2><p>这不会是本书最后一个出现并发的章节：第二十一章的项目会在更现实的场景中使用这些概念，而不像本章中讨论的这些小例子。</p><p>正如之前提到的，因为 Rust 本身很少有处理并发的部分内容，有很多的并发方案都由 crate 实现。它们比标准库要发展的更快；请在网上搜索当前最新的用于多线程场景的 crate。</p><p>Rust 提供了用于消息传递的信道，和像 <code>Mutex&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 这样可以安全的用于并发上下文的智能指针。类型系统和借用检查器会确保这些场景中的代码，不会出现数据竞争和无效的引用。一旦代码可以编译了，我们就可以坚信这些代码可以正确的运行于多线程环境，而不会出现其他语言中经常出现的那些难以追踪的 bug。并发编程不再是什么可怕的概念：无所畏惧地并发吧！</p><p>接下来，让我们讨论一下当 Rust 程序变得更大时，有哪些符合语言习惯的问题建模方法和结构化解决方案，以及 Rust 的风格是如何与面向对象编程（Object Oriented Programming）中那些你所熟悉的概念相联系的。</p>',8))])}const h=o(p,[["render",u]]),S=JSON.parse('{"path":"/ch16-04-extensible-concurrency-sync-and-send.html","title":"ch16-04-extensible-concurrency-sync-and-send","lang":"zh-CN","frontmatter":{"description":"使用 Sync 和 Send trait 的可扩展并发 ch16-04-extensible-concurrency-sync-and-send.md commit 7c7740a5ddef1458d74f1daf85fd49e03aaa97cf Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 甚少。我们之前讨论的几乎所有内容，都属于标准库...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch16-04-extensible-concurrency-sync-and-send.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"使用 Sync 和 Send trait 的可扩展并发 ch16-04-extensible-concurrency-sync-and-send.md commit 7c7740a5ddef1458d74f1daf85fd49e03aaa97cf Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 甚少。我们之前讨论的几乎所有内容，都属于标准库..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":4.13,"words":1240},"filePathRelative":"ch16-04-extensible-concurrency-sync-and-send.md","excerpt":"<h2>使用 <code>Sync</code> 和 <code>Send</code> trait 的可扩展并发</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch16-04-extensible-concurrency-sync-and-send.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch16-04-extensible-concurrency-sync-and-send.md</a><br>\\n<br><br>\\ncommit 7c7740a5ddef1458d74f1daf85fd49e03aaa97cf</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch16-04-extensible-concurrency-sync-and-send.md","value":{"title":"ch16-04-extensible-concurrency-sync-and-send","path":"ch16-04-extensible-concurrency-sync-and-send.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch16-04-extensible-concurrency-sync-and-send.md"},{"source":"SUMMARY.md","target":"ch16-04-extensible-concurrency-sync-and-send.md"}]}}}');export{h as comp,S as data};
