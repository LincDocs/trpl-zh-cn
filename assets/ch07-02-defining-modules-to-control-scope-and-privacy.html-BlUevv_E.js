import{_ as s,e as n,j as a,o as i}from"./app-jlAZUEML.js";const o={};function r(c,e){return i(),n("div",null,e[0]||(e[0]=[a(`<h2 id="定义模块来控制作用域与私有性" tabindex="-1"><a class="header-anchor" href="#定义模块来控制作用域与私有性"><span>定义模块来控制作用域与私有性</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch07-02-defining-modules-to-control-scope-and-privacy.md" target="_blank" rel="noopener noreferrer">ch07-02-defining-modules-to-control-scope-and-privacy.md</a><br><br><br> commit 310ea6cb0dd855eaf510c9ba05648bc5836ead0c</p></blockquote><p>在本节，我们将讨论模块和其它一些关于模块系统的部分，如允许你命名项的 <em>路径</em>（<em>paths</em>）；用来将路径引入作用域的 <code>use</code> 关键字；以及使项变为公有的 <code>pub</code> 关键字。我们还将讨论 <code>as</code> 关键字、外部包和 glob 运算符。现在，让我们把注意力放在模块上！</p><p>首先，我们将从一系列的规则开始，在你未来组织代码的时候，这些规则可被用作简单的参考。接下来我们将会详细的解释每条规则。</p><h2 id="模块小抄" tabindex="-1"><a class="header-anchor" href="#模块小抄"><span>模块小抄</span></a></h2><p>这里我们提供一个简单的参考，用来解释模块、路径、<code>use</code>关键词和<code>pub</code>关键词如何在编译器中工作，以及大部分开发者如何组织他们的代码。我们将在本章节中举例说明每条规则，不过这是一个解释模块工作方式的良好参考。</p><ul><li><strong>从 crate 根节点开始</strong>: 当编译一个 crate, 编译器首先在 crate 根文件（通常，对于一个库 crate 而言是<em>src/lib.rs</em>，对于一个二进制 crate 而言是<em>src/main.rs</em>）中寻找需要被编译的代码。</li><li><strong>声明模块</strong>: 在 crate 根文件中，你可以声明一个新模块；比如，你用<code>mod garden;</code>声明了一个叫做<code>garden</code>的模块。编译器会在下列路径中寻找模块代码： <ul><li>内联，在大括号中，当<code>mod garden</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src/garden.rs</em></li><li>在文件 <em>src/garden/mod.rs</em></li></ul></li><li><strong>声明子模块</strong>: 在除了 crate 根节点以外的其他文件中，你可以定义子模块。比如，你可能在<em>src/garden.rs</em>中定义了<code>mod vegetables;</code>。编译器会在以父模块命名的目录中寻找子模块代码： <ul><li>内联，在大括号中，当<code>mod vegetables</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src/garden/vegetables.rs</em></li><li>在文件 <em>src/garden/vegetables/mod.rs</em></li></ul></li><li><strong>模块中的代码路径</strong>: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块下的<code>Asparagus</code>类型可以在<code>crate::garden::vegetables::Asparagus</code>被找到。</li><li><strong>私有 vs 公用</strong>: 一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使用<code>pub mod</code>替代<code>mod</code>。为了使一个公用模块内部的成员公用，应当在声明前使用<code>pub</code>。</li><li><strong><code>use</code> 关键字</strong>: 在一个作用域内，<code>use</code>关键字创建了一个成员的快捷方式，用来减少长路径的重复。在任何可以引用<code>crate::garden::vegetables::Asparagus</code>的作用域，你可以通过 <code>use crate::garden::vegetables::Asparagus;</code>创建一个快捷方式，然后你就可以在作用域中只写<code>Asparagus</code>来使用该类型。</li></ul><p>这里我们创建一个名为<code>backyard</code>的二进制 crate 来说明这些规则。该 crate 的路径同样命名为<code>backyard</code>，该路径包含了这些文件和目录：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>backyard</span></span>
<span class="line"><span>├── Cargo.lock</span></span>
<span class="line"><span>├── Cargo.toml</span></span>
<span class="line"><span>└── src</span></span>
<span class="line"><span>    ├── garden</span></span>
<span class="line"><span>    │   └── vegetables.rs</span></span>
<span class="line"><span>    ├── garden.rs</span></span>
<span class="line"><span>    └── main.rs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子中的 crate 根文件是<em>src/main.rs</em>，该文件包括了：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,noplayground,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,ignore" data-title="rust,noplayground,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>pub mod garden;</code>行告诉编译器应该包含在<em>src/garden.rs</em>文件中发现的代码：</p><p><span class="filename">文件名：src/garden.rs</span></p><div class="language-rust,noplayground,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,ignore" data-title="rust,noplayground,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在此处， <code>pub mod vegetables;</code>意味着在<em>src/garden/vegetables.rs</em>中的代码也应该被包括。这些代码是：</p><div class="language-rust,noplayground,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,ignore" data-title="rust,noplayground,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden/vegetables.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在让我们深入了解这些规则的细节并在实际中演示它们！</p><h3 id="在模块中对相关代码进行分组" tabindex="-1"><a class="header-anchor" href="#在模块中对相关代码进行分组"><span>在模块中对相关代码进行分组</span></a></h3><p><em>模块</em> 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。因为一个模块中的代码默认是私有的，所以还可以利用模块控制项的 <em>私有性</em>。私有项是不可为外部使用的内在详细实现。我们也可以将模块和它其中的项标记为公开的，这样，外部代码就可以使用并依赖于它们。</p><p>在餐饮业，餐馆中会有一些地方被称之为 <em>前台</em>（<em>front of house</em>），还有另外一些地方被称之为 <em>后台</em>（<em>back of house</em>）。前台是招待顾客的地方，在这里，店主可以为顾客安排座位，服务员接受顾客下单和付款，调酒师会制作饮品。后台则是由厨师工作的厨房，洗碗工的工作地点，以及经理做行政工作的地方组成。</p><p>我们可以将函数放置到嵌套的模块中，来使我们的 crate 结构与实际的餐厅结构相同。通过执行 <code>cargo new --lib restaurant</code>，来创建一个新的名为 <code>restaurant</code> 的库。然后将示例 7-1 中所罗列出来的代码放入 <em>src/lib.rs</em> 中，来定义一些模块和函数。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-01/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 7-1：一个包含了其他内置了函数的模块的 <code>front_of_house</code> 模块</span></p><p>我们定义一个模块，是以 <code>mod</code> 关键字为起始，然后指定模块的名字（本例中叫做 <code>front_of_house</code>），并且用花括号包围模块的主体。在模块内，我们还可以定义其他的模块，就像本例中的 <code>hosting</code> 和 <code>serving</code> 模块。模块还可以保存一些定义的其他项，比如结构体、枚举、常量、特性、或者函数。</p><p>通过使用模块，我们可以将相关的定义分组到一起，并指出它们为什么相关。程序员可以通过使用这段代码，更加容易地找到他们想要的定义，因为他们可以基于分组来对代码进行导航，而不需要阅读所有的定义。程序员向这段代码中添加一个新的功能时，他们也会知道代码应该放置在何处，可以保持程序的组织性。</p><p>在前面我们提到了，<code>src/main.rs</code> 和 <code>src/lib.rs</code> 叫做 crate 根。之所以这样叫它们是因为这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 <code>crate</code> 的模块，该结构被称为 <em>模块树</em>（<em>module tree</em>）。</p><p>示例 7-2 展示了示例 7-1 中的模块树的结构。</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>crate</span></span>
<span class="line"><span> └── front_of_house</span></span>
<span class="line"><span>     ├── hosting</span></span>
<span class="line"><span>     │   ├── add_to_waitlist</span></span>
<span class="line"><span>     │   └── seat_at_table</span></span>
<span class="line"><span>     └── serving</span></span>
<span class="line"><span>         ├── take_order</span></span>
<span class="line"><span>         ├── serve_order</span></span>
<span class="line"><span>         └── take_payment</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><span class="caption">示例 7-2: 示例 7-1 中代码的模块树</span></p><p>这个树展示了一些模块是如何被嵌入到另一个模块的（例如，<code>hosting</code> 嵌套在 <code>front_of_house</code> 中）。这个树还展示了一些模块是互为 <em>兄弟</em>（<em>siblings</em>）的，这意味着它们定义在同一模块中（<code>hosting</code> 和 <code>serving</code> 被一起定义在 <code>front_of_house</code> 中）。继续沿用家庭关系的比喻，如果一个模块 A 被包含在模块 B 中，我们将模块 A 称为模块 B 的 <em>子</em>（<em>child</em>），模块 B 则是模块 A 的 <em>父</em>（<em>parent</em>）。注意，整个模块树都植根于名为 <code>crate</code> 的隐式模块下。</p><p>这个模块树可能会令你想起电脑上文件系统的目录树；这是一个非常恰当的类比！就像文件系统的目录，你可以使用模块来组织你的代码。并且，就像目录中的文件，我们需要一种方法来找到模块。</p>`,33)]))}const t=s(o,[["render",r],["__file","ch07-02-defining-modules-to-control-scope-and-privacy.html.vue"]]),l=JSON.parse('{"path":"/ch07-02-defining-modules-to-control-scope-and-privacy.html","title":"ch07-02-defining-modules-to-control-scope-and-privacy","lang":"zh-CN","frontmatter":{"description":"定义模块来控制作用域与私有性 ch07-02-defining-modules-to-control-scope-and-privacy.md commit 310ea6cb0dd855eaf510c9ba05648bc5836ead0c 在本节，我们将讨论模块和其它一些关于模块系统的部分，如允许你命名项的 路径（paths）；用来将路径引入作用域的 ...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch07-02-defining-modules-to-control-scope-and-privacy.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"定义模块来控制作用域与私有性 ch07-02-defining-modules-to-control-scope-and-privacy.md commit 310ea6cb0dd855eaf510c9ba05648bc5836ead0c 在本节，我们将讨论模块和其它一些关于模块系统的部分，如允许你命名项的 路径（paths）；用来将路径引入作用域的 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":6.35,"words":1905},"filePathRelative":"ch07-02-defining-modules-to-control-scope-and-privacy.md","excerpt":"<h2>定义模块来控制作用域与私有性</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch07-02-defining-modules-to-control-scope-and-privacy.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch07-02-defining-modules-to-control-scope-and-privacy.md</a><br>\\n<br><br>\\ncommit 310ea6cb0dd855eaf510c9ba05648bc5836ead0c</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch07-02-defining-modules-to-control-scope-and-privacy.md","value":{"title":"ch07-02-defining-modules-to-control-scope-and-privacy","path":"ch07-02-defining-modules-to-control-scope-and-privacy.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch07-02-defining-modules-to-control-scope-and-privacy.md"},{"source":"SUMMARY.md","target":"ch07-02-defining-modules-to-control-scope-and-privacy.md"}]}}}');export{t as comp,l as data};
