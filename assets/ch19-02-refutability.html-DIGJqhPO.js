import{_ as i,e as t,j as a,o}from"./app-oyO3eSzo.js";const c={};function s(l,e){return o(),t("div",null,e[0]||(e[0]=[a('<h2 id="refutability-可反驳性-模式是否会匹配失效" tabindex="-1"><a class="header-anchor" href="#refutability-可反驳性-模式是否会匹配失效"><span>Refutability（可反驳性）: 模式是否会匹配失效</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch19-02-refutability.md" target="_blank" rel="noopener noreferrer">ch19-02-refutability.md</a><br><br><br> commit 0c2d41e2afce734825c3a12087d423e8c2f0ae53</p></blockquote><p>模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 <strong>不可反驳的</strong>（<em>irrefutable</em>）。一个例子就是 <code>let x = 5;</code> 语句中的 <code>x</code>，因为 <code>x</code> 可以匹配任何值所以不可能会失败。对某些可能的值进行匹配会失败的模式被称为是 <strong>可反驳的</strong>（<em>refutable</em>）。一个这样的例子便是 <code>if let Some(x) = a_value</code> 表达式中的 <code>Some(x)</code>；如果变量 <code>a_value</code> 中的值是 <code>None</code> 而不是 <code>Some</code>，那么 <code>Some(x)</code> 模式不能匹配。</p><p>函数参数、<code>let</code> 语句和 <code>for</code> 循环只能接受不可反驳的模式，因为当值不匹配时，程序无法进行有意义的操作。<code>if let</code> 和 <code>while let</code> 表达式可以接受可反驳和不可反驳的模式，但编译器会对不可反驳的模式发出警告，因为根据定义它们旨在处理可能的失败：条件表达式的功能在于它能够根据成功或失败来执行不同的操作。</p><p>通常我们无需担心可反驳和不可反驳模式的区别，不过确实需要熟悉可反驳性的概念，这样当在错误信息中看到时就知道如何应对。遇到这些情况，根据代码行为的意图，需要修改模式或者使用模式的结构。</p><p>让我们看看一个尝试在 Rust 要求不可反驳模式的地方使用可反驳模式以及相反情况的例子。在示例 18-8 中，有一个 <code>let</code> 语句，不过模式被指定为可反驳模式 <code>Some(x)</code>。如你所见，这不能编译：</p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-08/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 18-8: 尝试在 <code>let</code> 中使用可反驳模式</span></p><p>如果 <code>some_option_value</code> 的值是 <code>None</code>，其不会成功匹配模式 <code>Some(x)</code>，表明这个模式是可反驳的。然而，因为 <code>let</code> 对于 <code>None</code> 匹配不能产生任何合法的代码，所以 <code>let</code> 语句只能接受不可反驳模式。Rust 会在编译时抱怨我们尝试在要求不可反驳模式的地方使用可反驳模式：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch19-patterns-and-matching/listing-19-08/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为我们没有覆盖（也不可能覆盖！）到模式 <code>Some(x)</code> 的每一个可能的值，所以 Rust 会合理地抗议。</p><p>为了修复在需要不可反驳模式的地方使用可反驳模式的情况，可以修改使用模式的代码：不同于使用 <code>let</code>，可以使用 <code>if let</code>。如此，如果模式不匹配，大括号中的代码将被忽略，其余代码保持有效。示例 18-9 展示了如何修复示例 18-8 中的代码。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-09/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 18-9: 使用 <code>if let</code> 和一个带有可反驳模式的代码块来代替 <code>let</code></span></p><p>我们给了代码一个得以继续的出路！虽然我们没办法在避免产生错误的情况下使用不可反驳模式，但这段使用可反驳模式的代码是完全有效的。如果为 <code>if let</code> 提供了一个总是会匹配的模式，比如示例 18-10 中的 <code>x</code>，编译器会给出一个警告：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-10/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 18-10: 尝试把不可反驳模式用到 <code>if let</code> 上</span></p><p>Rust 会抱怨将不可反驳模式用于 <code>if let</code> 是没有意义的：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch19-patterns-and-matching/listing-19-10/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>基于此，<code>match</code>匹配分支必须使用可反驳模式，除了最后一个分支需要使用能匹配任何剩余值的不可反驳模式。Rust 允许我们在只有一个匹配分支的<code>match</code>中使用不可反驳模式，不过这么做不是特别有用，并可以被更简单的 <code>let</code> 语句替代。</p><p>目前我们已经讨论了所有可以使用模式的地方，以及可反驳模式与不可反驳模式的区别，下面让我们一起去把可以用来创建模式的语法过目一遍吧。</p>',21)]))}const n=i(c,[["render",s],["__file","ch19-02-refutability.html.vue"]]),r=JSON.parse('{"path":"/ch19-02-refutability.html","title":"ch19-02-refutability","lang":"zh-CN","frontmatter":{"description":"Refutability（可反驳性）: 模式是否会匹配失效 ch19-02-refutability.md commit 0c2d41e2afce734825c3a12087d423e8c2f0ae53 模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 不可反驳的（irrefu...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch19-02-refutability.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"Refutability（可反驳性）: 模式是否会匹配失效 ch19-02-refutability.md commit 0c2d41e2afce734825c3a12087d423e8c2f0ae53 模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 不可反驳的（irrefu..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":3.58,"words":1075},"filePathRelative":"ch19-02-refutability.md","excerpt":"<h2>Refutability（可反驳性）: 模式是否会匹配失效</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch19-02-refutability.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch19-02-refutability.md</a><br>\\n<br><br>\\ncommit 0c2d41e2afce734825c3a12087d423e8c2f0ae53</p>\\n</blockquote>\\n<p>模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 <strong>不可反驳的</strong>（<em>irrefutable</em>）。一个例子就是 <code>let x = 5;</code> 语句中的 <code>x</code>，因为 <code>x</code> 可以匹配任何值所以不可能会失败。对某些可能的值进行匹配会失败的模式被称为是 <strong>可反驳的</strong>（<em>refutable</em>）。一个这样的例子便是 <code>if let Some(x) = a_value</code> 表达式中的 <code>Some(x)</code>；如果变量 <code>a_value</code> 中的值是 <code>None</code> 而不是 <code>Some</code>，那么 <code>Some(x)</code> 模式不能匹配。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch19-02-refutability.md","value":{"title":"ch19-02-refutability","path":"ch19-02-refutability.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"ch19-02-refutability.md"}]}}}');export{n as comp,r as data};
