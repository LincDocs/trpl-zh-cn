import{_ as i,e as s,j as n,o as d}from"./app-oyO3eSzo.js";const o={};function a(r,e){return d(),s("div",null,e[0]||(e[0]=[n(`<h2 id="优雅停机与清理" tabindex="-1"><a class="header-anchor" href="#优雅停机与清理"><span>优雅停机与清理</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md" target="_blank" rel="noopener noreferrer">ch21-03-graceful-shutdown-and-cleanup.md</a><br><br><br> commit 3e5105b52f7e8d3d95def07ffade4dcb1cfdee27</p></blockquote><p>示例 20-20 中的代码如期通过使用线程池异步的响应请求。这里有一些警告说 <code>workers</code>、<code>id</code> 和 <code>thread</code> 字段没有直接被使用，这提醒了我们并没有清理所有的内容。当使用不那么优雅的 <span class="keystroke">ctrl-c</span> 终止主线程时，所有其他线程也会立刻停止，即便它们正处于处理请求的过程中。</p><p>现在我们要为 <code>ThreadPool</code> 实现 <code>Drop</code> trait 对线程池中的每一个线程调用 <code>join</code>，这样这些线程将会执行完它们的请求。接着会为 <code>ThreadPool</code> 实现一个告诉线程它们应该停止接收新请求并结束的方式。为了实践这些代码，修改 server 在优雅停机（graceful shutdown）之前只接受两个请求。</p><h3 id="为-threadpool-实现-drop-trait" tabindex="-1"><a class="header-anchor" href="#为-threadpool-实现-drop-trait"><span>为 <code>ThreadPool</code> 实现 <code>Drop</code> Trait</span></a></h3><p>现在开始为线程池实现 <code>Drop</code>。当线程池被丢弃时，应该 join 所有线程以确保它们完成其操作。示例 20-22 展示了 <code>Drop</code> 实现的第一次尝试；这些代码还不能够编译：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/listing-21-22/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 20-22: 当线程池离开作用域时 join 每个线程</span></p><p>这里首先遍历线程池中的每个 <code>workers</code>。这里使用了 <code>&amp;mut</code> 因为 <code>self</code> 本身是一个可变引用而且也需要能够修改 <code>worker</code>。对于每一个线程，会打印出说明信息表明此特定 worker 正在关闭，接着在 worker 线程上调用 <code>join</code>。如果 <code>join</code> 调用失败，通过 <code>unwrap</code> 使得 panic 并进行不优雅的关闭。</p><p>如下是尝试编译代码时得到的错误：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch21-web-server/listing-21-22/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的错误告诉我们并不能调用 <code>join</code>，因为我们只有每一个 <code>worker</code> 的可变借用，而 <code>join</code> 需要获取其参数的所有权。为了解决这个问题，需要一个方法将 <code>thread</code> 移动出拥有其所有权的 <code>Worker</code> 实例以便 <code>join</code> 可以消费这个线程。示例 17-15 中我们曾见过这么做的方法：如果 <code>Worker</code> 存放的是 <code>Option&lt;thread::JoinHandle&lt;()&gt;</code>，就可以在 <code>Option</code> 上调用 <code>take</code> 方法将值从 <code>Some</code> 成员中移动出来而对 <code>None</code> 成员不做处理。换句话说，正在运行的 <code>Worker</code> 的 <code>thread</code> 将是 <code>Some</code> 成员值，而当需要清理 worker 时，将 <code>Some</code> 替换为 <code>None</code>，这样 worker 就没有可以运行的线程了。</p><p>为此需要更新 <code>Worker</code> 的定义为如下：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/no-listing-04-update-worker-definition/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在依靠编译器来找出其他需要修改的地方。check 代码会得到两个错误：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch21-web-server/no-listing-04-update-worker-definition/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>让我们修复第二个错误，它指向 <code>Worker::new</code> 结尾的代码；当新建 <code>Worker</code> 时需要将 <code>thread</code> 值封装进 <code>Some</code>。做出如下改变以修复问题：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/no-listing-05-fix-worker-new/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第一个错误位于 <code>Drop</code> 实现中。之前提到过要调用 <code>Option</code> 上的 <code>take</code> 将 <code>thread</code> 移动出 <code>worker</code>。如下改变会修复问题：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,ignore,not_desired_behavior line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,not_desired_behavior" data-title="rust,ignore,not_desired_behavior" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/no-listing-06-fix-threadpool-drop/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如第十八章我们见过的，<code>Option</code> 上的 <code>take</code> 方法会取出 <code>Some</code> 而留下 <code>None</code>。使用 <code>if let</code> 解构 <code>Some</code> 并得到线程，接着在线程上调用 <code>join</code>。如果 worker 的线程已然是 <code>None</code>，就知道此时这个 worker 已经清理了其线程所以无需做任何操作。</p><h3 id="向线程发送信号使其停止接收任务" tabindex="-1"><a class="header-anchor" href="#向线程发送信号使其停止接收任务"><span>向线程发送信号使其停止接收任务</span></a></h3><p>有了所有这些修改，代码就能编译且没有任何警告。不过也有坏消息，这些代码还不能以我们期望的方式运行。问题的关键在于 <code>Worker</code> 中分配的线程所运行的闭包中的逻辑：调用 <code>join</code> 并不会关闭线程，因为它们一直 <code>loop</code> 来寻找任务。如果采用这个实现来尝试丢弃 <code>ThreadPool</code>，则主线程会永远阻塞在等待第一个线程结束上。</p><p>为了修复这个问题，我们将修改 <code>ThreadPool</code> 的 <code>drop</code> 实现并修改 <code>Worker</code> 循环。</p><p>首先修改 <code>ThreadPool</code> 的 <code>drop</code> 实现在等待线程结束前显式丢弃 <code>sender</code>。示例 20-23 展示了 <code>ThreadPool</code> 显式丢弃 <code>sender</code> 所作的修改。我们使用了与之前处理线程时相同的 <code>Option</code> 和 <code>take</code> 技术以便能从 <code>ThreadPool</code> 中移动 <code>sender</code>：</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground,not_desired_behavior line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground,not_desired_behavior" data-title="rust,noplayground,not_desired_behavior" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/listing-21-23/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 20-23: 在 join worker 线程之前显式丢弃 <code>sender</code></span></p><p>丢弃 <code>sender</code> 会关闭信道，这表明不会有更多的消息被发送。这时 worker 中的无限循环中的所有 <code>recv</code> 调用都会返回错误。在示例 20-24 中，我们修改 <code>Worker</code> 循环在这种情况下优雅地退出，这意味着当 <code>ThreadPool</code> 的 <code>drop</code> 实现调用 <code>join</code> 时线程会结束。</p><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/listing-21-24/src/lib.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 20-24：当 <code>recv</code> 返回错误时显式退出循环</span></p><p>为了实践这些代码，如示例 20-25 所示修改 <code>main</code> 在优雅停机 server 之前只接受两个请求：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/listing-21-25/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 20-25: 在处理两个请求之后通过退出循环来停止 server</span></p><p>你不会希望真实世界的 web server 只处理两次请求就停机了，这只是为了展示优雅停机和清理处于正常工作状态。</p><p><code>take</code> 方法定义于 <code>Iterator</code> trait，这里限制循环最多头 2 次。<code>ThreadPool</code> 会在 <code>main</code> 的结尾离开作用域，而且还会看到 <code>drop</code> 实现的运行。</p><p>使用 <code>cargo run</code> 启动 server，并发起三个请求。第三个请求应该会失败，而终端的输出应该看起来像这样：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo run</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   Compiling hello v0.1.0 (file:///projects/hello)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Finished dev [unoptimized + debuginfo] target(s) in 1.0s</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     Running \`target/debug/hello\`</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Worker 0 got a job; executing.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Shutting down.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Shutting down worker 0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Worker 3 got a job; executing.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Worker 1 disconnected; shutting down.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Worker 2 disconnected; shutting down.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Worker 3 disconnected; shutting down.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Worker 0 disconnected; shutting down.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Shutting down worker 1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Shutting down worker 2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Shutting down worker 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可能会出现不同顺序的 worker 和信息输出。可以从信息中看到服务是如何运行的：worker 0 和 worker 3 获取了头两个请求。server 会在头第二个请求后停止接受请求，<code>ThreadPool</code> 的 <code>Drop</code> 实现甚至会在 worker 3 开始工作之前就开始执行。丢弃 <code>sender</code> 会断开所有 worker 的连接并让它们关闭。每个 worker 在断开时会打印出一个信息，接着线程池调用 <code>join</code> 来等待每一个 worker 线程结束。</p><p>这个特定的运行过程中一个有趣的地方在于：<code>ThreadPool</code> 丢弃 <code>sender</code>，而在任何线程收到消息之前，就尝试 join worker 0 了。worker 0 还没有从 <code>recv</code> 获得一个错误，所以主线程阻塞直到 worker 0 结束。与此同时，worker 3 接收到一个任务接着所有线程会收到一个错误。一旦 worker 0 结束，主线程就等待余下其他 worker 结束。此时它们都退出了循环并停止。</p><p>恭喜！现在我们完成了这个项目，也有了一个使用线程池异步响应请求的基础 web server。我们能对 server 执行优雅停机，它会清理线程池中的所有线程。</p><p>如下是完整的代码参考：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/no-listing-07-final-code/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="filename">文件名：src/lib.rs</span></p><div class="language-rust,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,noplayground" data-title="rust,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch21-web-server/no-listing-07-final-code/src/lib.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里还有很多可以做的事！如果你希望继续增强这个项目，如下是一些点子：</p><ul><li>为 <code>ThreadPool</code> 和其公有方法增加更多文档</li><li>为库的功能增加测试</li><li>将 <code>unwrap</code> 调用改为更健壮的错误处理</li><li>使用 <code>ThreadPool</code> 进行其他不同于处理网络请求的任务</li><li>在 <a href="https://crates.io/" target="_blank" rel="noopener noreferrer">crates.io</a> 上寻找一个线程池 crate 并使用它实现一个类似的 web server，将其 API 和鲁棒性与我们的实现做对比</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>好极了！你结束了本书的学习！由衷感谢你同我们一道加入这次 Rust 之旅。现在你已经准备好出发并实现自己的 Rust 项目并帮助他人了。请不要忘记我们的社区，这里有其他 Rustaceans 正乐于帮助你迎接 Rust 之路上的任何挑战。</p>`,56)]))}const l=i(o,[["render",a],["__file","ch21-03-graceful-shutdown-and-cleanup.html.vue"]]),t=JSON.parse('{"path":"/ch21-03-graceful-shutdown-and-cleanup.html","title":"ch21-03-graceful-shutdown-and-cleanup","lang":"zh-CN","frontmatter":{"description":"优雅停机与清理 ch21-03-graceful-shutdown-and-cleanup.md commit 3e5105b52f7e8d3d95def07ffade4dcb1cfdee27 示例 20-20 中的代码如期通过使用线程池异步的响应请求。这里有一些警告说 workers、id 和 thread 字段没有直接被使用，这提醒了我们并没有清理...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch21-03-graceful-shutdown-and-cleanup.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"优雅停机与清理 ch21-03-graceful-shutdown-and-cleanup.md commit 3e5105b52f7e8d3d95def07ffade4dcb1cfdee27 示例 20-20 中的代码如期通过使用线程池异步的响应请求。这里有一些警告说 workers、id 和 thread 字段没有直接被使用，这提醒了我们并没有清理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":7.25,"words":2176},"filePathRelative":"ch21-03-graceful-shutdown-and-cleanup.md","excerpt":"<h2>优雅停机与清理</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch21-03-graceful-shutdown-and-cleanup.md</a><br>\\n<br><br>\\ncommit 3e5105b52f7e8d3d95def07ffade4dcb1cfdee27</p>\\n</blockquote>\\n<p>示例 20-20 中的代码如期通过使用线程池异步的响应请求。这里有一些警告说 <code>workers</code>、<code>id</code> 和 <code>thread</code> 字段没有直接被使用，这提醒了我们并没有清理所有的内容。当使用不那么优雅的 <span class=\\"keystroke\\">ctrl-c</span> 终止主线程时，所有其他线程也会立刻停止，即便它们正处于处理请求的过程中。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch21-03-graceful-shutdown-and-cleanup.md","value":{"title":"ch21-03-graceful-shutdown-and-cleanup","path":"ch21-03-graceful-shutdown-and-cleanup.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"ch21-03-graceful-shutdown-and-cleanup.md"}]}}}');export{l as comp,t as data};
