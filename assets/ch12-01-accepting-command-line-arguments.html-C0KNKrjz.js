import{_ as d,e as l,j as s,f as n,i,g as a,h as o,r,o as c}from"./app-CtoJuC-b.js";const p={};function g(m,e){const t=r("RouteLink");return c(),l("div",null,[e[32]||(e[32]=s('<h2 id="接受命令行参数" tabindex="-1"><a class="header-anchor" href="#接受命令行参数"><span>接受命令行参数</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md" target="_blank" rel="noopener noreferrer">ch12-01-accepting-command-line-arguments.md</a><br><br><br> commit 02a168ed346042f07010f8b65b4eeed623dd31d1</p></blockquote><p>一如既往使用 <code>cargo new</code> 新建一个项目，我们称之为 <code>minigrep</code> 以便与可能已经安装在系统上的 <code>grep</code> 工具相区别：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo new minigrep</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     Created binary (application) `minigrep` project</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cd minigrep</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个任务是让 <code>minigrep</code> 能够接受两个命令行参数：文件路径和要搜索的字符串。也就是说我们希望能够使用 <code>cargo run</code>、要搜索的字符串和被搜索的文件的路径来运行程序，像这样：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo run -- searchstring example-filename.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在 <code>cargo new</code> 生成的程序忽略任何传递给它的参数。<a href="https://crates.io/" target="_blank" rel="noopener noreferrer">Crates.io</a> 上有一些现成的库可以帮助我们接受命令行参数，不过我们正在学习这些内容，让我们自己来实现一个。</p><h3 id="读取参数值" tabindex="-1"><a class="header-anchor" href="#读取参数值"><span>读取参数值</span></a></h3>',8)),n("p",null,[e[1]||(e[1]=i("为了确保 ")),e[2]||(e[2]=n("code",null,"minigrep",-1)),e[3]||(e[3]=i(" 能够获取传递给它的命令行参数的值，我们需要一个 Rust 标准库提供的函数 ")),e[4]||(e[4]=n("code",null,"std::env::args",-1)),e[5]||(e[5]=i("。这个函数返回一个传递给程序的命令行参数的 ")),e[6]||(e[6]=n("strong",null,"迭代器",-1)),e[7]||(e[7]=i("（")),e[8]||(e[8]=n("em",null,"iterator",-1)),e[9]||(e[9]=i("）。我们会在 ")),a(t,{to:"/ch13-00-functional-features.html"},{default:o(()=>e[0]||(e[0]=[i("第十三章")])),_:1}),e[10]||(e[10]=i(" 全面的介绍它们。但是现在只需理解迭代器的两个细节：迭代器生成一系列的值，可以在迭代器上调用 ")),e[11]||(e[11]=n("code",null,"collect",-1)),e[12]||(e[12]=i(" 方法将其转换为一个集合，比如包含所有迭代器产生元素的 vector。"))]),e[33]||(e[33]=s('<p>示例 12-1 中允许 <code>minigrep</code> 程序读取任何传递给它的命令行参数并将其收集到一个 vector 中。</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 12-1：将命令行参数收集到一个 vector 中并打印出来</span></p>',4)),n("p",null,[e[14]||(e[14]=i("首先使用 ")),e[15]||(e[15]=n("code",null,"use",-1)),e[16]||(e[16]=i(" 语句来将 ")),e[17]||(e[17]=n("code",null,"std::env",-1)),e[18]||(e[18]=i(" 模块引入作用域以便可以使用它的 ")),e[19]||(e[19]=n("code",null,"args",-1)),e[20]||(e[20]=i(" 函数。注意 ")),e[21]||(e[21]=n("code",null,"std::env::args",-1)),e[22]||(e[22]=i(" 函数被嵌套进了两层模块中。正如 ")),a(t,{to:"/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#%E5%88%9B%E5%BB%BA%E6%83%AF%E7%94%A8%E7%9A%84-use-%E8%B7%AF%E5%BE%84"},{default:o(()=>e[13]||(e[13]=[i("第七章")])),_:1}),e[23]||(e[23]=i(" 讲到的，当所需函数嵌套了多于一层模块时，通常将父模块引入作用域，而不是其自身。这便于我们利用 ")),e[24]||(e[24]=n("code",null,"std::env",-1)),e[25]||(e[25]=i(" 中的其他函数。这比增加了 ")),e[26]||(e[26]=n("code",null,"use std::env::args;",-1)),e[27]||(e[27]=i(" 后仅仅使用 ")),e[28]||(e[28]=n("code",null,"args",-1)),e[29]||(e[29]=i(" 调用函数要更明确一些，因为 ")),e[30]||(e[30]=n("code",null,"args",-1)),e[31]||(e[31]=i(" 容易被错认成一个定义于当前模块的函数。"))]),e[34]||(e[34]=s('<blockquote><h3 id="args-函数和无效的-unicode" tabindex="-1"><a class="header-anchor" href="#args-函数和无效的-unicode"><span><code>args</code> 函数和无效的 Unicode</span></a></h3><p>注意 <code>std::env::args</code> 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 <code>std::env::args_os</code> 代替。这个函数返回 <code>OsString</code> 值而不是 <code>String</code> 值。这里出于简单考虑使用了 <code>std::env::args</code>，因为 <code>OsString</code> 值每个平台都不一样而且比 <code>String</code> 值处理起来更为复杂。</p></blockquote><p>在 <code>main</code> 函数的第一行，我们调用了 <code>env::args</code>，并立即使用 <code>collect</code> 来创建了一个包含迭代器所有值的 vector。<code>collect</code> 可以被用来创建很多类型的集合，所以这里显式注明 <code>args</code> 的类型来指定我们需要一个字符串 vector。虽然在 Rust 中我们很少会需要注明类型，然而 <code>collect</code> 是一个经常需要注明类型的函数，因为 Rust 不能推断出你想要什么类型的集合。</p><p>最后，我们使用调试宏打印出 vector。让我们尝试分别用两种方式（不包含参数和包含参数）运行代码：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意 vector 的第一个值是 <code>&quot;target/debug/minigrep&quot;</code>，它是我们二进制文件的名称。这与 C 中的参数列表的行为相匹配，让程序使用在执行时调用它们的名称。如果要在消息中打印它或者根据用于调用程序的命令行别名更改程序的行为，通常可以方便地访问程序名称，不过考虑到本章的目的，我们将忽略它并只保存所需的两个参数。</p><h3 id="将参数值保存进变量" tabindex="-1"><a class="header-anchor" href="#将参数值保存进变量"><span>将参数值保存进变量</span></a></h3><p>目前程序可以访问指定为命令行参数的值。现在需要将这两个参数的值保存进变量这样就可以在程序的余下部分使用这些值了。让我们如示例 12-2 这样做：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,should_panic,noplayground line-numbers-mode" data-highlighter="shiki" data-ext="rust,should_panic,noplayground" data-title="rust,should_panic,noplayground" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 12-2：创建变量来存放查询参数和文件路径参数</span></p><p>正如之前打印出 vector 时所看到的，程序的名称占据了 vector 的第一个值 <code>args[0]</code>，所以我们从索引为 <code>1</code> 的参数开始。<code>minigrep</code> 获取的第一个参数是需要搜索的字符串，所以将第一个参数的引用存放在变量 <code>query</code> 中。第二个参数将是文件路径，所以将第二个参数的引用放入变量 <code>file_path</code> 中。</p><p>我们将临时打印出这些变量的值来证明代码如我们期望的那样工作。使用参数 <code>test</code> 和 <code>sample.txt</code> 再次运行这个程序：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>好的，它可以工作！我们将所需的参数值保存进了对应的变量中。之后会增加一些错误处理来应对类似用户没有提供参数的情况，不过现在我们将忽略它们并开始增加读取文件功能。</p>',15))])}const h=d(p,[["render",g],["__file","ch12-01-accepting-command-line-arguments.html.vue"]]),k=JSON.parse('{"path":"/ch12-01-accepting-command-line-arguments.html","title":"ch12-01-accepting-command-line-arguments","lang":"zh-CN","frontmatter":{"description":"接受命令行参数 ch12-01-accepting-command-line-arguments.md commit 02a168ed346042f07010f8b65b4eeed623dd31d1 一如既往使用 cargo new 新建一个项目，我们称之为 minigrep 以便与可能已经安装在系统上的 grep 工具相区别： 第一个任务是让 min...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch12-01-accepting-command-line-arguments.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"接受命令行参数 ch12-01-accepting-command-line-arguments.md commit 02a168ed346042f07010f8b65b4eeed623dd31d1 一如既往使用 cargo new 新建一个项目，我们称之为 minigrep 以便与可能已经安装在系统上的 grep 工具相区别： 第一个任务是让 min..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":4.61,"words":1383},"filePathRelative":"ch12-01-accepting-command-line-arguments.md","excerpt":"<h2>接受命令行参数</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch12-01-accepting-command-line-arguments.md</a><br>\\n<br><br>\\ncommit 02a168ed346042f07010f8b65b4eeed623dd31d1</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch12-01-accepting-command-line-arguments.md","value":{"title":"ch12-01-accepting-command-line-arguments","path":"ch12-01-accepting-command-line-arguments.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch12-01-accepting-command-line-arguments.md"},{"source":"SUMMARY.md","target":"ch12-01-accepting-command-line-arguments.md"}]}}}');export{h as comp,k as data};
