import{_ as t,e as c,j as o,o as s}from"./app-DVGyNizL.js";const d={};function i(a,e){return s(),c("div",null,e[0]||(e[0]=[o('<h2 id="共享状态的并发" tabindex="-1"><a class="header-anchor" href="#共享状态的并发"><span>共享状态的并发</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch16-03-shared-state.md" target="_blank" rel="noopener noreferrer">ch16-03-shared-state.md</a><br><br><br> commit 856d89c53a6d69470bb5669c773fdfe6aab6fcc9</p></blockquote><p>消息传递是一个很好的处理并发的方式，但并不是唯一一个。另一种方式是让多个线程访问同一块内存中的数据（共享状态）。再考虑一下 Go 语言文档中的这句口号：“不要通过共享内存来通讯”（“do not communicate by sharing memory.”</p><p>通过共享内存进行通信，会是什么样的代码？此外，为什么喜欢消息传递的人会警告：谨慎使用内存共享？</p><p>在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。在 15 章中，我们介绍了智能指针可以实现多所有权，然而这会增加额外的复杂性，因为需要管理多个所有者。Rust 的类型系统和所有权规则在正确管理这些问题上提供了极大的帮助：举个例子，让我们来看看 <strong>互斥器</strong>，一个较常见的共享内存并发原语。</p><h3 id="使用互斥器-实现同一时刻只允许一个线程访问数据" tabindex="-1"><a class="header-anchor" href="#使用互斥器-实现同一时刻只允许一个线程访问数据"><span>使用互斥器，实现同一时刻只允许一个线程访问数据</span></a></h3><p><strong>互斥器</strong>（<em>mutex</em>）是 互相排斥（<em>mutual exclusion</em>）的缩写。在同一时刻，其只允许一个线程对数据拥有访问权。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个数据结构，作为互斥器的一部分，它记录谁有数据的专属访问权。因此我们讲，互斥器通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p><p>互斥器以难以使用著称（译注：原文指互斥器在其他编程语言中难以使用），因为你必须记住：</p><ol><li>在使用数据之前，必须获取锁。</li><li>使用完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li></ol><p>作为一个现实中互斥器的例子，想象一下在某个会议的一次小组座谈会中，只有一个麦克风。如果一位成员要发言，他必须请求或表示希望使用麦克风。得到了麦克风后，他可以畅所欲言，讲完后再将麦克风交给下一位希望讲话的成员。如果一位成员结束发言后忘记将麦克风交还，其他人将无法发言。如果对共享麦克风的管理出现了问题，座谈会将无法正常进行！</p><p>正确的管理互斥器异常复杂，这也是许多人之所以热衷于信道的原因。然而，在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。</p><h3 id="mutex-t-的-api" tabindex="-1"><a class="header-anchor" href="#mutex-t-的-api"><span><code>Mutex&lt;T&gt;</code>的 API</span></a></h3><p>我们先从在单线程环境中使用互斥器开始，作为展示其用法的一个例子，如示例 16-12 所示：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-12/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 16-12: 出于简单的考虑，在一个单线程上下文中探索 <code>Mutex&lt;T&gt;</code> 的 API</span></p><p>像很多类型一样，我们使用关联函数 <code>new</code> 来创建一个 <code>Mutex&lt;T&gt;</code>。使用 <code>lock</code> 方法来获取锁，从而可以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。</p><p>如果另一个线程拥有锁，并且那个线程 panic 了，则 <code>lock</code> 调用会失败。在这种情况下，没人能够再获取锁，所以我们调用 <code>unwrap</code>，使当前线程 panic。</p><p>一旦获取了锁，就可以将返回值（命名为 <code>num</code>）视为一个其内部数据（<code>i32</code>）的可变引用了。类型系统确保了我们在使用 <code>m</code> 中的值之前获取锁。<code>m</code> 的类型是 <code>Mutex&lt;i32&gt;</code> 而不是 <code>i32</code>，所以 <strong>必须</strong> 获取锁才能使用这个 <code>i32</code> 值。我们是不会忘记这么做的，因为如果没有获取锁，类型系统就不允许访问内部的 <code>i32</code> 值。</p><p>正如你所猜想的，<code>Mutex&lt;T&gt;</code> 是一个智能指针。更准确的说，<code>lock</code> 调用 <strong>返回</strong> 一个叫做 <code>MutexGuard</code> 的智能指针。这个智能指针实现了 <code>Deref</code> 来指向其内部数据；它也实现了 <code>Drop</code>，当 <code>MutexGuard</code> 离开作用域时，自动释放锁（发生在示例 16-12 内部作用域的结尾）。有了这个特性，就不会有忘记释放锁的潜在风险（忘记释放锁会使互斥器无法再被其它线程使用），因为锁的释放是自动发生的。</p><p>释放锁之后，我们可以打印出互斥器内部的 <code>i32</code> 值，并发现我们刚刚已经将其值改为 6。</p><h4 id="在线程间共享-mutex-t" tabindex="-1"><a class="header-anchor" href="#在线程间共享-mutex-t"><span>在线程间共享 <code>Mutex&lt;T&gt;</code></span></a></h4><p>现在让我们尝试使用 <code>Mutex&lt;T&gt;</code> 在多个线程间共享同一个值。我们将启动 10 个线程，并在各个线程中对同一个计数器值加 1，这样计数器将从 0 变为 10。示例 16-13 中的例子会出现编译错误，而我们将通过这些错误来学习如何使用 <code>Mutex&lt;T&gt;</code>，以及 Rust 又是如何帮助我们正确使用的。</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-13/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 16-13: 程序启动了 10 个线程，每个线程都通过 <code>Mutex&lt;T&gt;</code> 来增加计数器的值</span></p><p>这里创建了一个 <code>counter</code> 变量来存放内含 <code>i32</code> 的 <code>Mutex&lt;T&gt;</code>，类似示例 16-12 那样。接下来我们遍历整数区间，创建了 10 个线程。我们使用了 <code>thread::spawn</code>，并为所有线程传入了相同的闭包：它们每一个都将调用 <code>lock</code> 方法来获取 <code>Mutex&lt;T&gt;</code> 上的锁，接着将互斥器中的值加一。当一个线程结束执行，<code>num</code> 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。</p><p>在主线程中，我们像示例 16-2 那样收集了所有的 <code>JoinHandle</code>，并调用它们的 <code>join</code> 方法来等待所有线程结束。然后，主线程会获取锁，并打印出程序的结果。</p><p>之前提示过，这个例子不能编译，让我们看看为什么！</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch16-fearless-concurrency/listing-16-13/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>错误信息表明 <code>counter</code> 值在上一次循环中被移动了。所以 Rust 告诉我们，不能将 <code>counter</code> 锁的所有权移动到多个线程中。让我们通过一个第 15 章讨论过的多所有权手段，来修复这个编译错误。</p><h4 id="多线程和多所有权" tabindex="-1"><a class="header-anchor" href="#多线程和多所有权"><span>多线程和多所有权</span></a></h4><p>在第 15 章中，我们用智能指针 <code>Rc&lt;T&gt;</code> 来创建引用计数，使得一个值有了多个所有者。让我们做同样的事，看看会发生什么。将示例 16-14 中的 <code>Mutex&lt;T&gt;</code> 封装进 <code>Rc&lt;T&gt;</code> 中，并在将所有权移入线程之前克隆（clone） <code>Rc&lt;T&gt;</code>。</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore,does_not_compile line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore,does_not_compile" data-title="rust,ignore,does_not_compile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-14/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 16-14: 尝试使用 <code>Rc&lt;T&gt;</code> 来允许多个线程拥有 <code>Mutex&lt;T&gt;</code></span></p><p>再一次编译并...出现了不同的错误！编译器真是教会了我们很多！</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{{#include ../listings/ch16-fearless-concurrency/listing-16-14/output.txt}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>哇哦，错误信息太长不看！划重点：第一行错误表明 <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> 不能在线程间安全传递（<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>）；编译器也指出了原因：<code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> 没有实现 <code>Send</code> trait（<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>）。下一节我们会讲到 <code>Send</code>：这是一个确保所使用的类型可以用于并发环境的 trait。</p><p>不幸的是，<code>Rc&lt;T&gt;</code> 并不能安全的在线程间共享。当 <code>Rc&lt;T&gt;</code> 管理引用计数时，它必须在每一个 <code>clone</code> 调用时增加计数，并在每一个克隆体被丢弃时减少计数。<code>Rc&lt;T&gt;</code> 并没有使用任何并发原语，无法确保改变计数的操作不会被其他线程打断。这可能使计数出错，并导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个与 <code>Rc&lt;T&gt;</code> 完全一致，又以线程安全的方式改变引用计数的类型。</p><h4 id="原子引用计数-arc-t" tabindex="-1"><a class="header-anchor" href="#原子引用计数-arc-t"><span>原子引用计数 <code>Arc&lt;T&gt;</code></span></a></h4><p>所幸 <code>Arc&lt;T&gt;</code> 正是这么一个类似 <code>Rc&lt;T&gt;</code> 并可以安全的用于并发环境的类型。字母 “a” 代表 <strong>原子性</strong>（<em>atomic</em>），所以这是一个 <strong>原子引用计数</strong>（<em>atomically reference counted</em>）类型。<strong>原子类型</strong> (Atomics) 是另一类这里还未涉及到的并发原语：请查看标准库中 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html" target="_blank" rel="noopener noreferrer"><code>std::sync::atomic</code></a> 的文档来获取更多细节。目前我们只需要知道：原子类型就像基本类型一样，可以安全地在线程间共享。</p><p>你可能会好奇，为什么不是所有的基本类型都是原子性的？为什么标准库中的类型没有全部默认使用 <code>Arc&lt;T&gt;</code> 实现？原因在于，线程安全会造成性能损失，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，而不加入原子性可以使代码运行得更快。</p><p>回到之前的例子：<code>Arc&lt;T&gt;</code> 和 <code>Rc&lt;T&gt;</code> 有着相同的 API，所以我们只需修改程序中的 <code>use</code> 行、<code>new</code> 调用和 <code>clone</code> 调用。示例 16-15 中的代码最终可以编译和运行：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-15/src/main.rs}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 16-15: 使用 <code>Arc&lt;T&gt;</code> 包装一个 <code>Mutex&lt;T&gt;</code> 能够实现在多线程之间共享所有权</span></p><p>这会打印出：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Result: 10</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>成功了！我们从 0 数到了 10，这好像没啥大不了的，不过一路上我们确实学习了很多关于 <code>Mutex&lt;T&gt;</code> 和线程安全的内容！这个例子中构建的结构可以用于比增加计数更为复杂的操作。使用这个策略，我们可将计算任务分成独立的部分，并分散到多个线程中，接着使用 <code>Mutex&lt;T&gt;</code> 使用各自的运算结果来更新最终的结果。</p><p>注意，对于简单的数值运算，<a href="https://doc.rust-lang.org/std/sync/atomic/index.html" target="_blank" rel="noopener noreferrer">标准库中 <code>std::sync::atomic</code> 模块</a> 提供了比 <code>Mutex&lt;T&gt;</code> 更简单的类型。针对基本类型，这些类型提供了安全、并发、原子的操作。在上面的例子中，为了专注于讲明白 <code>Mutex&lt;T&gt;</code> 的用法，我们才选择在基本类型上使用 <code>Mutex&lt;T&gt;</code>。（译注：对于上面例子中出现的 <code>i32</code> 加法操作，更好的做法是使用 <code>AtomicI32</code> 类型来完成。具体参考文档。）</p><h3 id="refcell-t-rc-t-与-mutex-t-arc-t-的相似性" tabindex="-1"><a class="header-anchor" href="#refcell-t-rc-t-与-mutex-t-arc-t-的相似性"><span><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 的相似性</span></a></h3><p>你可能注意到了，尽管 <code>counter</code> 是不可变的，我们仍然可以获取其内部值的可变引用；这意味着 <code>Mutex&lt;T&gt;</code> 提供了内部可变性，就像 <code>Cell</code> 系列类型那样。使用 <code>RefCell&lt;T&gt;</code> 可以改变 <code>Rc&lt;T&gt;</code> 中内容（在 15 章中讲到过），同样地，使用 <code>Mutex&lt;T&gt;</code> 我们也可以改变 <code>Arc&lt;T&gt;</code> 中的内容。</p><p>另一个值得注意的细节是，Rust 不能完全避免使用 <code>Mutex&lt;T&gt;</code> 所带来的逻辑错误。回忆一下，第 15 章中讲过，使用 <code>Rc&lt;T&gt;</code> 就有造成引用循环的风险：两个 <code>Rc&lt;T&gt;</code> 值相互引用，造成内存泄漏。同理，<code>Mutex&lt;T&gt;</code> 也有造成 <strong>死锁</strong>（<em>deadlock</em>）的风险：当某个操作需要锁住两个资源，而两个线程分别持有两个资源的其中一个锁时，它们会永远相互等待。如果你对这个话题感兴趣，尝试编写一个带有死锁的 Rust 程序，接着研究别的语言中使用互斥器的死锁规避策略，并尝试在 Rust 中实现它们。标准库中 <code>Mutex&lt;T&gt;</code> 和 <code>MutexGuard</code> 的 API 文档会提供有用的信息。</p><p>接下来，为了丰富本章的内容，让我们讨论一下 <code>Send</code>和 <code>Sync</code> trait，以及如何对自定义类型使用它们。</p>',55)]))}const r=t(d,[["render",i],["__file","ch16-03-shared-state.html.vue"]]),l=JSON.parse('{"path":"/ch16-03-shared-state.html","title":"ch16-03-shared-state","lang":"zh-CN","frontmatter":{"description":"共享状态的并发 ch16-03-shared-state.md commit 856d89c53a6d69470bb5669c773fdfe6aab6fcc9 消息传递是一个很好的处理并发的方式，但并不是唯一一个。另一种方式是让多个线程访问同一块内存中的数据（共享状态）。再考虑一下 Go 语言文档中的这句口号：“不要通过共享内存来通讯”（“do not...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch16-03-shared-state.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"共享状态的并发 ch16-03-shared-state.md commit 856d89c53a6d69470bb5669c773fdfe6aab6fcc9 消息传递是一个很好的处理并发的方式，但并不是唯一一个。另一种方式是让多个线程访问同一块内存中的数据（共享状态）。再考虑一下 Go 语言文档中的这句口号：“不要通过共享内存来通讯”（“do not..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":10.37,"words":3112},"filePathRelative":"ch16-03-shared-state.md","excerpt":"<h2>共享状态的并发</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch16-03-shared-state.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch16-03-shared-state.md</a><br>\\n<br><br>\\ncommit 856d89c53a6d69470bb5669c773fdfe6aab6fcc9</p>\\n</blockquote>\\n<p>消息传递是一个很好的处理并发的方式，但并不是唯一一个。另一种方式是让多个线程访问同一块内存中的数据（共享状态）。再考虑一下 Go 语言文档中的这句口号：“不要通过共享内存来通讯”（“do not communicate by sharing memory.”</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch16-03-shared-state.md","value":{"title":"ch16-03-shared-state","path":"ch16-03-shared-state.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch16-03-shared-state.md"},{"source":"SUMMARY.md","target":"ch16-03-shared-state.md"}]}}}');export{r as comp,l as data};
