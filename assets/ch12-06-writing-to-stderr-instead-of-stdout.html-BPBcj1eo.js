import{_ as t,e as i,j as s,o as n}from"./app-oyO3eSzo.js";const a={};function r(d,e){return n(),i("div",null,e[0]||(e[0]=[s(`<h2 id="将错误信息输出到标准错误而不是标准输出" tabindex="-1"><a class="header-anchor" href="#将错误信息输出到标准错误而不是标准输出"><span>将错误信息输出到标准错误而不是标准输出</span></a></h2><blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch12-06-writing-to-stderr-instead-of-stdout.md" target="_blank" rel="noopener noreferrer">ch12-06-writing-to-stderr-instead-of-stdout.md</a><br><br><br> commit 02a168ed346042f07010f8b65b4eeed623dd31d1</p></blockquote><p>目前为止，我们将所有的输出都通过 <code>println!</code> 写到了终端。大部分终端都提供了两种输出：<strong>标准输出</strong>（<em>standard output</em>，<code>stdout</code>）对应一般信息，<strong>标准错误</strong>（<em>standard error</em>，<code>stderr</code>）则用于错误信息。这种区别允许用户选择将程序正常输出定向到一个文件中并仍将错误信息打印到屏幕上。</p><p>但是 <code>println!</code> 宏只能够打印到标准输出，所以我们必须使用其他方法来打印到标准错误。</p><h3 id="检查错误应该写入何处" tabindex="-1"><a class="header-anchor" href="#检查错误应该写入何处"><span>检查错误应该写入何处</span></a></h3><p>首先，让我们观察一下目前 <code>minigrep</code> 打印的所有内容是如何被写入标准输出的，包括那些应该被写入标准错误的错误信息。可以通过将标准输出流重定向到一个文件同时有意产生一个错误来做到这一点。我们没有重定向标准错误流，所以任何发送到标准错误的内容将会继续显示在屏幕上。</p><p>命令行程序被期望将错误信息发送到标准错误流，这样即便选择将标准输出流重定向到文件中时仍然能看到错误信息。目前我们的程序并不符合期望；相反我们将看到它将错误信息输出保存到了文件中！</p><p>我们通过 <code>&gt;</code> 和文件路径 <em>output.txt</em> 来运行程序，我们期望重定向标准输出流到该文件中。在这里，我们没有传递任何参数，所以会产生一个错误：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo run &gt; output.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>&gt;</code> 语法告诉 shell 将标准输出的内容写入到 <em>output.txt</em> 文件中而不是屏幕上。我们并没有看到期望的错误信息打印到屏幕上，所以这意味着它一定被写入了文件中。如下是 <em>output.txt</em> 所包含的：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Problem parsing arguments: not enough arguments</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>是的，错误信息被打印到了标准输出中。像这样的错误信息被打印到标准错误中将会有用得多，将使得只有成功运行所产生的输出才会写入文件。我们接下来就修改。</p><h3 id="将错误打印到标准错误" tabindex="-1"><a class="header-anchor" href="#将错误打印到标准错误"><span>将错误打印到标准错误</span></a></h3><p>让我们如示例 12-24 所示的代码改变错误信息是如何被打印的。得益于本章早些时候的重构，所有打印错误信息的代码都位于 <code>main</code> 一个函数中。标准库提供了 <code>eprintln!</code> 宏来打印到标准错误流，所以将两个调用 <code>println!</code> 打印错误信息的位置替换为 <code>eprintln!</code>：</p><p><span class="filename">文件名：src/main.rs</span></p><div class="language-rust,ignore line-numbers-mode" data-highlighter="shiki" data-ext="rust,ignore" data-title="rust,ignore" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-24/src/main.rs:here}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><span class="caption">示例 12-24：使用 <code>eprintln!</code> 将错误信息写入标准错误而不是标准输出</span></p><p>现在我们再次尝试用同样的方式运行程序，不使用任何参数并通过 <code>&gt;</code> 重定向标准输出：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo run &gt; output.txt</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Problem parsing arguments: not enough arguments</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们看到了屏幕上的错误信息，同时 <em>output.txt</em> 里什么也没有，这正是命令行程序所期望的行为。</p><p>如果使用不会造成错误的参数再次运行程序，不过仍然将标准输出重定向到一个文件，像这样：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo run -- to poem.txt &gt; output.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们并不会在终端看到任何输出，同时 <code>output.txt</code> 将会包含其结果：</p><p><span class="filename">文件名：output.txt</span></p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Are you nobody, too?</span></span>
<span class="line"><span>How dreary to be somebody!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这一部分展示了现在我们适当的使用了成功时产生的标准输出和错误时产生的标准错误。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>在这一章中，我们回顾了目前为止的一些主要章节并涉及了如何在 Rust 环境中进行常规的 I/O 操作。通过使用命令行参数、文件、环境变量和打印错误的 <code>eprintln!</code> 宏，现在你已经准备好编写命令行程序了。通过结合前几章的知识，你的代码将会是组织良好的，并能有效的将数据存储到合适的数据结构中、更好的处理错误，并且还是经过良好测试的。</p><p>接下来，让我们探索一些 Rust 中受函数式编程语言影响的功能：闭包和迭代器。</p>`,29)]))}const l=t(a,[["render",r],["__file","ch12-06-writing-to-stderr-instead-of-stdout.html.vue"]]),c=JSON.parse('{"path":"/ch12-06-writing-to-stderr-instead-of-stdout.html","title":"ch12-06-writing-to-stderr-instead-of-stdout","lang":"zh-CN","frontmatter":{"description":"将错误信息输出到标准错误而不是标准输出 ch12-06-writing-to-stderr-instead-of-stdout.md commit 02a168ed346042f07010f8b65b4eeed623dd31d1 目前为止，我们将所有的输出都通过 println! 写到了终端。大部分终端都提供了两种输出：标准输出（standard ou...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/trpl-zh-cn/ch12-06-writing-to-stderr-instead-of-stdout.html"}],["meta",{"property":"og:site_name","content":"trpl-zh-cn"}],["meta",{"property":"og:description","content":"将错误信息输出到标准错误而不是标准输出 ch12-06-writing-to-stderr-instead-of-stdout.md commit 02a168ed346042f07010f8b65b4eeed623dd31d1 目前为止，我们将所有的输出都通过 println! 写到了终端。大部分终端都提供了两种输出：标准输出（standard ou..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/trpl-zh-cn/\\"}]}"]]},"git":{},"readingTime":{"minutes":3.74,"words":1121},"filePathRelative":"ch12-06-writing-to-stderr-instead-of-stdout.md","excerpt":"<h2>将错误信息输出到标准错误而不是标准输出</h2>\\n<blockquote>\\n<p><a href=\\"https://github.com/rust-lang/book/blob/main/src/ch12-06-writing-to-stderr-instead-of-stdout.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ch12-06-writing-to-stderr-instead-of-stdout.md</a><br>\\n<br><br>\\ncommit 02a168ed346042f07010f8b65b4eeed623dd31d1</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"README","link":"README.html"},{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"ch12-06-writing-to-stderr-instead-of-stdout.md","value":{"title":"ch12-06-writing-to-stderr-instead-of-stdout","path":"ch12-06-writing-to-stderr-instead-of-stdout.md","outlink":[],"backlink":["README.md","SUMMARY.md"]}},{"id":"README.md","value":{"title":"README","path":"README.md","outlink":[],"backlink":[]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"README.md","target":"ch12-06-writing-to-stderr-instead-of-stdout.md"},{"source":"SUMMARY.md","target":"ch12-06-writing-to-stderr-instead-of-stdout.md"}]}}}');export{l as comp,c as data};
